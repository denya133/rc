// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  module.exports = function(Module) {
    var ASYNC, CoreObject, FuncG, HookedObject, HookedObjectInterface, NilT, _, isGeneratorFunction;
    ({
      NilT,
      FuncG,
      ASYNC,
      CoreObject,
      HookedObjectInterface,
      Utils: {isGeneratorFunction, _}
    } = Module.prototype);
    return HookedObject = (function() {
      var ipmDoHook, ipoAnchor;

      class HookedObject extends CoreObject {};

      HookedObject.inheritProtected();

      HookedObject.implements(HookedObjectInterface);

      HookedObject.module(Module);

      ipoAnchor = HookedObject.protected({
        anchor: Object
      });

      ipmDoHook = HookedObject.protected(HookedObject.async({
        doHook: Function
      }, {
        default: function*(asHook, alArguments, asErrorMessage, aDefaultValue) {
          var anchor, ref, ref1, ref2, ref3;
          anchor = (ref = this[ipoAnchor]) != null ? ref : this;
          if (asHook != null) {
            if (_.isFunction(anchor[asHook])) {
              if (((ref1 = anchor.constructor.instanceMethods) != null ? (ref2 = ref1[asHook]) != null ? ref2.async : void 0 : void 0) === ASYNC) {
                return (yield anchor[asHook](...alArguments));
              } else if (isGeneratorFunction((ref3 = anchor[asHook].body) != null ? ref3 : anchor[asHook])) {
                return (yield* anchor[asHook](...alArguments));
              } else {
                return (yield Module.prototype.Promise.resolve(anchor[asHook](...alArguments)));
              }
            } else if (_.isString(anchor[asHook])) {
              return (yield Module.prototype.Promise.resolve(typeof anchor.emit === "function" ? anchor.emit(anchor[asHook], ...alArguments) : void 0));
            } else {
              throw new Error(asErrorMessage);
            }
          } else {
            return (yield Module.prototype.Promise.resolve(aDefaultValue));
          }
        }
      }));

      HookedObject.public({
        name: String
      });

      HookedObject.public({
        init: FuncG([String, Object], NilT)
      }, {
        default: function(name, anchor) {
          this.name = name;
          this.super(...arguments);
          if (anchor != null) {
            this[ipoAnchor] = anchor;
          }
        }
      });

      HookedObject.initialize();

      return HookedObject;

    }).call(this);
  };

}).call(this);
