// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  var splice = [].splice;

  /*
  Stand-alone or mixed-in class (via StateMachineMixin)

  Inspiration:

  - https://github.com/PureMVC/puremvc-js-util-statemachine
  - https://github.com/aasm/aasm
  */
  module.exports = function(Module) {
    var DictG, FuncG, HookedObject, ListG, MaybeG, NilT, PointerT, StateInterface, StateMachine, StateMachineInterface, StructG, TransitionInterface, UnionG, _, co;
    ({
      NilT,
      PointerT,
      MaybeG,
      FuncG,
      DictG,
      ListG,
      StructG,
      UnionG,
      HookedObject,
      StateInterface,
      TransitionInterface,
      StateMachineInterface,
      Utils: {co, _}
    } = Module.prototype);
    return StateMachine = (function() {
      var iplTransitionConfigs, ipmDoHook, ipsAfterAllErrors, ipsAfterAllEvents, ipsAfterAllTransitions, ipsAfterReset, ipsBeforeAllEvents, ipsBeforeReset, ipsWithAnchorRestoreState, ipsWithAnchorSave, ipsWithAnchorUpdateState;

      class StateMachine extends HookedObject {};

      StateMachine.inheritProtected();

      StateMachine.implements(StateMachineInterface);

      StateMachine.module(Module);

      // @public name: String
      StateMachine.public({
        currentState: MaybeG(StateInterface)
      });

      StateMachine.public({
        initialState: MaybeG(StateInterface)
      });

      StateMachine.public({
        states: DictG(String, StateInterface)
      });

      ipmDoHook = PointerT(StateMachine.instanceMethods['~doHook'].pointer);

      iplTransitionConfigs = PointerT(StateMachine.private({
        _transitionConfigs: MaybeG(ListG(StructG({
          previousStates: ListG(String),
          nextState: String,
          config: MaybeG(Object)
        })))
      }));

      ipsBeforeReset = PointerT(StateMachine.private({
        _beforeReset: MaybeG(String)
      }));

      ipsAfterReset = PointerT(StateMachine.private({
        _afterReset: MaybeG(String)
      }));

      ipsBeforeAllEvents = PointerT(StateMachine.private({
        _beforeAllEvents: MaybeG(String)
      }));

      ipsAfterAllEvents = PointerT(StateMachine.private({
        _afterAllEvents: MaybeG(String)
      }));

      ipsAfterAllTransitions = PointerT(StateMachine.private({
        _afterAllTransitions: MaybeG(String)
      }));

      ipsAfterAllErrors = PointerT(StateMachine.private({
        _errorOnAllEvents: MaybeG(String)
      }));

      ipsWithAnchorUpdateState = PointerT(StateMachine.private({
        _withAnchorUpdateState: MaybeG(String)
      }));

      ipsWithAnchorRestoreState = PointerT(StateMachine.private({
        _withAnchorRestoreState: MaybeG(String)
      }));

      ipsWithAnchorSave = PointerT(StateMachine.private({
        _withAnchorSave: MaybeG(String)
      }));

      StateMachine.public(StateMachine.async({
        doBeforeReset: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsBeforeReset], args, 'Specified "beforeReset" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doAfterReset: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsAfterReset], args, 'Specified "afterReset" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doBeforeAllEvents: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsBeforeAllEvents], args, 'Specified "beforeAllEvents" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doAfterAllEvents: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsAfterAllEvents], args, 'Specified "afterAllEvents" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doAfterAllTransitions: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsAfterAllTransitions], args, 'Specified "afterAllTransitions" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doErrorOnAllEvents: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsAfterAllErrors], args, 'Specified "errorOnAllEvents" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doWithAnchorUpdateState: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsWithAnchorUpdateState], args, 'Specified "withAnchorUpdateState" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doWithAnchorRestoreState: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsWithAnchorRestoreState], args, 'Specified "withAnchorRestoreState" not found', args));
        }
      }));

      StateMachine.public(StateMachine.async({
        doWithAnchorSave: Function
      }, {
        default: function*(...args) {
          return (yield this[ipmDoHook](this[ipsWithAnchorSave], args, 'Specified "withAnchorSave" not found', args));
        }
      }));

      StateMachine.public({
        registerState: FuncG([String, MaybeG(Object)], StateInterface)
      }, {
        default: function(name, config = {}) {
          var state, vpoAnchor;
          if (this.states[name] != null) {
            throw new Error(`State with specified name ${name} is already registered`);
          }
          vpoAnchor = this[Symbol.for('~anchor')];
          this.states[name] = state = Module.prototype.State.new(name, vpoAnchor, this, config);
          if (state.initial) {
            this.initialState = state;
          }
          return state;
        }
      });

      StateMachine.public({
        removeState: FuncG(String, Boolean)
      }, {
        default: function(name) {
          var removedState;
          if ((removedState = this.states[name]) != null) {
            delete this.states[name];
            if (this.initialState === removedState) {
              this.initialState = null;
            }
            if (this.currentState === removedState) {
              this.currentState = null;
            }
            return true;
          }
          return false;
        }
      });

      StateMachine.public({
        registerEvent: FuncG([String, UnionG(String, ListG(String)), String, MaybeG(Object), MaybeG(Object)], NilT)
      }, {
        default: function(asEvent, alDepartures, asTarget, ahEventConfig = {}, ahTransitionConfig = {}) {
          var i, len, vlDepartues, voAnchor, voNextState, vsState;
          vlDepartues = _.castArray(alDepartures);
          voNextState = this.states[asTarget];
          voAnchor = this[Symbol.for('~anchor')];
          for (i = 0, len = vlDepartues.length; i < len; i++) {
            vsState = vlDepartues[i];
            (function(voState) {
              var voTransition, vsTransitionName;
              if (voState != null) {
                vsTransitionName = `${voState.name}_${asEvent}`;
                voTransition = Module.prototype.Transition.new(vsTransitionName, voAnchor, ahTransitionConfig);
                voState.defineTransition(asEvent, voNextState, voTransition, ahEventConfig);
              }
            })(this.states[vsState]);
          }
        }
      });

      StateMachine.public(StateMachine.async({
        reset: Function
      }, {
        default: function*() {
          var restoredState;
          yield this.doBeforeReset();
          restoredState = this.states[(yield this.doWithAnchorRestoreState())];
          this.currentState = restoredState != null ? restoredState : this.initialState;
          if (this.currentState != null) {
            yield this.doWithAnchorUpdateState(this.currentState.name);
          }
          yield this.doAfterReset();
        }
      }));

      StateMachine.public(StateMachine.async({
        send: FuncG(String, NilT)
      }, {
        default: function*(asEvent, ...args) {
          var err, stateMachine;
          stateMachine = this;
          try {
            yield stateMachine.doBeforeAllEvents(...args);
            yield stateMachine.currentState.send(asEvent, ...args);
            yield stateMachine.doAfterAllEvents(...args);
          } catch (error) {
            err = error;
            yield stateMachine.doErrorOnAllEvents(err);
          }
        }
      }));

      StateMachine.public(StateMachine.async({
        transitionTo: FuncG([StateInterface, TransitionInterface], NilT)
      }, {
        default: function*(nextState, transition, ...args) {
          var oldState, stateMachine;
          stateMachine = this;
          oldState = stateMachine.currentState;
          stateMachine.currentState = nextState;
          yield stateMachine.doWithAnchorUpdateState(nextState.name);
          yield stateMachine.doAfterAllTransitions(...args);
          yield transition.doAfter(...args);
          yield nextState.doBeforeEnter(...args);
          yield nextState.doEnter(...args);
          yield stateMachine.doWithAnchorSave();
          yield transition.doSuccess(...args);
          yield oldState.doAfterExit(...args);
          yield nextState.doAfterEnter(...args);
        }
      }));

      StateMachine.public({
        init: FuncG([String, Object, MaybeG(Object)], NilT)
      }, {
        default: function(name1, anchor, ...args1) {
          var config, ref;
          ref = args1, [...args1] = ref, [config] = splice.call(args1, -1);
          if (config === void 0) {
            config = {};
          }
          this.name = name1;
          this.super(...arguments);
          this.states = {};
          ({
            beforeReset: this[ipsBeforeReset],
            afterReset: this[ipsAfterReset],
            beforeAllEvents: this[ipsBeforeAllEvents],
            afterAllEvents: this[ipsAfterAllEvents],
            afterAllTransitions: this[ipsAfterAllTransitions],
            errorOnAllEvents: this[ipsAfterAllErrors],
            withAnchorUpdateState: this[ipsWithAnchorUpdateState],
            withAnchorSave: this[ipsWithAnchorSave],
            withAnchorRestoreState: this[ipsWithAnchorRestoreState]
          } = config);
        }
      });

      // Mixin intializer methods
      StateMachine.public({
        beforeAllEvents: FuncG(String, NilT)
      }, {
        default: function(asMethod) {
          this[ipsBeforeAllEvents] = asMethod;
        }
      });

      StateMachine.public({
        afterAllTransitions: FuncG(String, NilT)
      }, {
        default: function(asMethod) {
          this[ipsAfterAllTransitions] = asMethod;
        }
      });

      StateMachine.public({
        afterAllEvents: FuncG(String, NilT)
      }, {
        default: function(asMethod) {
          this[ipsAfterAllEvents] = asMethod;
        }
      });

      StateMachine.public({
        errorOnAllEvents: FuncG(String, NilT)
      }, {
        default: function(asMethod) {
          this[ipsAfterAllErrors] = asMethod;
        }
      });

      StateMachine.public({
        withAnchorUpdateState: FuncG(String, NilT)
      }, {
        default: function(asMethod) {
          this[ipsWithAnchorUpdateState] = asMethod;
        }
      });

      StateMachine.public({
        withAnchorSave: FuncG(String, NilT)
      }, {
        default: function(asMethod) {
          this[ipsWithAnchorSave] = asMethod;
        }
      });

      StateMachine.public({
        withAnchorRestoreState: FuncG(String, NilT)
      }, {
        default: function(asMethod) {
          this[ipsWithAnchorRestoreState] = asMethod;
        }
      });

      StateMachine.public({
        state: FuncG([String, MaybeG(Object)], NilT)
      }, {
        default: function(asState, ahConfig) {
          this.registerState(asState, ahConfig);
        }
      });

      StateMachine.public({
        event: FuncG([String, UnionG(Object, Function), MaybeG(Function)], NilT)
      }, {
        default: function(asEvent, ahConfig, amTransitionInitializer) {
          var base, i, len, name1, nextState, previousStates, ref, transitionConf, transitionConfig, transitionConfigs;
          if (_.isFunction(ahConfig)) {
            amTransitionInitializer = ahConfig;
            ahConfig = {};
          }
          if (!_.isFunction(amTransitionInitializer)) {
            amTransitionInitializer = function() {};
          }
          this.constructor[iplTransitionConfigs] = null;
          amTransitionInitializer.call(this);
          transitionConfigs = this.constructor[iplTransitionConfigs];
          this.constructor[iplTransitionConfigs] = null;
          for (i = 0, len = transitionConfigs.length; i < len; i++) {
            transitionConf = transitionConfigs[i];
            ({
              previousStates,
              nextState,
              config: transitionConfig
            } = transitionConf);
            this.registerEvent(asEvent, previousStates, nextState, ahConfig, transitionConfig);
          }
          if ((ref = this[Symbol.for('~anchor')]) != null) {
            if (typeof (base = ref.constructor)[name1 = Symbol.for('~defineSpecialMethods')] === "function") {
              base[name1](asEvent, this);
            }
          }
        }
      });

      StateMachine.public({
        transition: FuncG([ListG(String), String, MaybeG(Object)], NilT)
      }, {
        default: function(previousStates, nextState, ahConfig) {
          var base;
          ((base = this.constructor)[iplTransitionConfigs] != null ? base[iplTransitionConfigs] : base[iplTransitionConfigs] = []).push({
            previousStates: previousStates,
            nextState: nextState,
            config: ahConfig
          });
        }
      });

      StateMachine.initialize();

      return StateMachine;

    }).call(this);
  };

}).call(this);
