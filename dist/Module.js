// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  var indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;

  /*
    ```
    ```
  */
  module.exports = function(RC) {
    var CACHE, CoreObject, DEVELOPMENT, PRODUCTION, PUBLIC, SOFT, _, assert, inflect, isArangoDB, ref, ref1, ref2, ref3, t;
    ({PUBLIC, PRODUCTION, DEVELOPMENT, CACHE, SOFT, CoreObject} = RC.prototype);
    _ = (ref = RC.prototype._) != null ? ref : RC.prototype.Utils._;
    t = (ref1 = RC.prototype.t) != null ? ref1 : RC.prototype.Utils.t;
    inflect = (ref2 = RC.prototype.inflect) != null ? ref2 : RC.prototype.Utils.inflect;
    isArangoDB = (ref3 = RC.prototype.isArangoDB) != null ? ref3 : RC.prototype.Utils.isArangoDB;
    ({assert} = t);
    RC.prototype.Module = (function() {
      var cphUtilsMap, cpmDefineProperty, cpmUtilsHandler, cpoUtils, cpoUtilsMeta;

      class Module extends CoreObject {
        constructor() {
          super();
          if (this instanceof RC.prototype.Module) {
            assert.fail('new operator unsupported');
          }
        }

      };

      Module.inheritProtected();

      Module.module(RC);

      cphUtilsMap = Symbol.for('~utilsMap');

      cpoUtils = Symbol.for('~utils');

      cpoUtilsMeta = Symbol.for('~utilsMeta');

      cpmUtilsHandler = Symbol.for('~utilsHandler');

      cpmDefineProperty = Symbol.for('~defineProperty');

      Reflect.defineProperty(Module, 'new', {
        enumerable: true,
        value: function() {
          return assert.fail('new method unsupported for Module');
        }
      });

      Reflect.defineProperty(Module, cphUtilsMap, {
        enumerable: true,
        writable: true,
        value: null
      });

      Reflect.defineProperty(Module, cpoUtils, {
        enumerable: true,
        writable: true,
        value: null
      });

      Reflect.defineProperty(Module, cpoUtilsMeta, {
        enumerable: true,
        writable: true,
        value: null
      });

      Reflect.defineProperty(Module, cpmUtilsHandler, {
        enumerable: true,
        value: function(aClass) {
          return {
            ownKeys: function(aoTarget) {
              return Reflect.ownKeys(aClass.utilities);
            },
            has: function(aoTarget, asName) {
              return indexOf.call(aClass.utilities, asName) >= 0;
            },
            set: function(aoTarget, asName, aValue, aoReceiver) {
              if (!Reflect.get(aClass.prototype, asName)) {
                return aClass.util(asName, aValue);
              }
            },
            get: function(aoTarget, asName) {
              var vsPath;
              if (!Reflect.get(aClass.prototype, asName)) {
                vsPath = aClass[cphUtilsMap][asName];
                if (vsPath) {
                  require(vsPath)(aClass);
                }
              }
              return Reflect.get(aClass.prototype, asName);
            }
          };
        }
      });

      Reflect.defineProperty(Module, 'utilities', {
        enumerable: true,
        get: function() {
          return this[cpoUtilsMeta] != null ? this[cpoUtilsMeta] : this[cpoUtilsMeta] = this.metaObject.getGroup('utilities', false);
        }
      });

      Reflect.defineProperty(Module, 'Module', {
        enumerable: true,
        get: function() {
          return this;
        }
      });

      Reflect.defineProperty(Module, 'environment', {
        enumerable: true,
        get: function() {
          var ref4;
          if (isArangoDB()) {
            if (module.context.isProduction) {
              return PRODUCTION;
            } else {
              return DEVELOPMENT;
            }
          } else {
            if ((typeof process !== "undefined" && process !== null ? (ref4 = process.env) != null ? ref4.NODE_ENV : void 0 : void 0) === 'production') {
              return PRODUCTION;
            } else {
              return DEVELOPMENT;
            }
          }
        }
      });

      Reflect.defineProperty(Module, 'root', {
        enumerable: true,
        value: function(path) {
          return this.prototype.ROOT = path;
        }
      });

      // чтобы в базовом коде мог через DI искать классы, по строковым константам, которые объявляются в унаследованных классах
      Reflect.defineProperty(Module, 'lookup', {
        enumerable: true,
        value: function(fullname) {
          var name, ref4, section, vsName, vsSection;
          [section, name] = fullname.split(':');
          vsSection = inflect.camelize(section);
          vsName = inflect.camelize(name);
          return (ref4 = this.prototype[`${vsName}${vsSection}`]) != null ? ref4 : null;
        }
      });

      Reflect.defineProperty(Module, 'defineMixin', {
        enumerable: true,
        value: function(...args) {
          var res, vmFunction, vsBaseClass;
          assert(args.length > 0, 'defineMixin() method required min one lambda argument');
          if (args.length === 2) {
            [vsBaseClass, vmFunction] = args;
            vmFunction = this.Module.prototype.Mixin(vsBaseClass, vmFunction);
          } else if (args.length === 1) {
            [vmFunction] = args;
          }
          res = this.const({
            [`${vmFunction.name}`]: vmFunction
          });
          return res;
        }
      });

      Reflect.defineProperty(Module, 'defineGeneric', {
        enumerable: true,
        value: function(amFunction) {
          var res;
          assert(_.isFunction(amFunction), `Invalid argument amFunction ${assert.stringify(amFunction)} supplied to defineGeneric(amFunction) (expected a function)`);
          res = this.const({
            [`${amFunction.name}`]: amFunction
          });
          return res;
        }
      });

      Reflect.defineProperty(Module, 'defineType', {
        enumerable: true,
        value: function(amFunction) {
          var res;
          assert(_.isFunction(amFunction), `Invalid argument amFunction ${assert.stringify(amFunction)} supplied to defineInterface(amFunction) (expected a function)`);
          res = this.const({
            [`${amFunction.name}`]: amFunction
          });
          return res;
        }
      });

      Reflect.defineProperty(Module, 'defineInterface', {
        enumerable: true,
        value: function(amFunction) {
          var res;
          assert(_.isFunction(amFunction), `Invalid argument amFunction ${assert.stringify(amFunction)} supplied to defineInterface(amFunction) (expected a function)`);
          res = this.const({
            [`${amFunction.name}`]: amFunction
          });
          return res;
        }
      });

      Reflect.defineProperty(Module, 'util', {
        enumerable: true,
        value: function(...args) {
          var vmLambda, voConfig, vsName;
          switch (args.length) {
            case 1:
              [voConfig] = args;
              [vsName] = Object.keys(voConfig != null ? voConfig : {});
              vmLambda = (voConfig != null ? voConfig : {})[vsName];
              break;
            case 2:
              [vsName, vmLambda] = args;
          }
          assert(_.isString(vsName) && (_.isObject(vmLambda) || _.isFunction(vmLambda)), 'Util should be defined as { "name": lambda } object or as name, lambda arguments');
          this[cpoUtilsMeta] = void 0;
          return this[cpmDefineProperty]({
            attr: vsName,
            attrType: null,
            level: PUBLIC,
            isUtility: true,
            default: vmLambda
          });
        }
      });

      Reflect.defineProperty(Module.prototype, 'Utils', {
        enumerable: true,
        set: function(ahConfig) {
          var vValue, vsKey;
          for (vsKey in ahConfig) {
            if (!hasProp.call(ahConfig, vsKey)) continue;
            vValue = ahConfig[vsKey];
            if (!this.Module.prototype[vsKey]) {
              this.constructor.util(vsKey, vValue);
            }
          }
        },
        get: function() {
          var MClass;
          MClass = this.constructor;
          if (MClass[cphUtilsMap] == null) {
            MClass[cphUtilsMap] = (function() {
              var vsRoot;
              vsRoot = `${MClass.prototype.ROOT}/utils`;
              return MClass.prototype.filesTreeSync(vsRoot, {
                filesOnly: true
              }).reduce(function(vhResult, vsItem) {
                var blackhole, ref4, vsName;
                if (/\.(js|coffee)$/.test(vsItem)) {
                  [blackhole, vsName] = (ref4 = vsItem.match(/([\w\-\_]+)\.(js|coffee)$/)) != null ? ref4 : [];
                  if (vsItem && vsName) {
                    vhResult[_.camelCase(vsName)] = `${vsRoot}/${vsItem}`;
                  }
                }
                return vhResult;
              }, {});
            })();
          }
          return MClass[cpoUtils] != null ? MClass[cpoUtils] : MClass[cpoUtils] = new Proxy({}, MClass[cpmUtilsHandler](MClass));
        }
      });

      Reflect.defineProperty(Module, 'displayName', {
        configurable: false,
        enumerable: true,
        get: function() {
          return this.name;
        }
      });

      Reflect.defineProperty(Module, 'cacheStrategy', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: SOFT
      });

      Reflect.defineProperty(Module, 'meta', {
        configurable: false,
        enumerable: true,
        get: function() {
          return {
            kind: 'module',
            name: this.name,
            identity: true
          };
        }
      });

      return Module;

    }).call(this);
    return CACHE.set(RC.prototype.Module, 'Module');
  };

}).call(this);
