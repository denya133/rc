// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  var hasProp = {}.hasOwnProperty;

  module.exports = function(Module) {
    var CACHE, CoreObject, Generic, PRODUCTION, SOFT, _, assert, createByType, getTypeName, instanceOf;
    ({
      PRODUCTION,
      CACHE,
      SOFT,
      CoreObject,
      Generic,
      Utils: {
        _,
        t: {assert},
        getTypeName,
        createByType,
        instanceOf
      }
    } = Module.prototype);
    return Module.defineGeneric(Generic('Declare', function(name) {
      var Declare, DeclareID, declare;
      if (Module.environment !== PRODUCTION) {
        assert(_.isString(name), `Invalid argument name ${assert.stringify(name)} supplied to Declare(name) (expected a string)`);
      }
      DeclareID = name;
      Declare = class Declare {
        constructor() {
          if (this instanceof Declare) {
            assert.fail('new operator unsupported');
          }
        }

      };
      declare = new Proxy(Declare, {
        apply: function(target, thisArg, argumentsList) {
          var actual, attrType, instanceVirtualMethods, instanceVirtualVariables, k, path, props, ref, ref1, value;
          [value, path] = argumentsList;
          if (Module.environment === PRODUCTION) {
            return value;
          }
          path = (path != null ? path : []).concat([target.name]);
          assert(value != null, `Invalid value ${assert.stringify(value)} supplied to ${path.join('.')}`);
          assert(target.Type != null, 'Type declared but not defined, don\'t forget to call .define on every declared type');
          if (Module.prototype.TypeT.is(target.Type) && target.Type.meta.kind === 'union') {
            assert(target.Type.dispatch === target.dispatch, `Please define the custom ${target.name}.dispatch function before calling ${target.name}.define()`);
          }
          // chachedValue = switch
          //   when _.isNumber(value) and not _.isObject(value)
          //     new Number value
          //   when _.isString(value) and not _.isObject(value)
          //     new String value
          //   when _.isBoolean(value) and not _.isObject(value)
          //     new Boolean value
          //   else
          //     value
          if (Declare.has(value)) { //chachedValue
            return value;
          }
          Declare.keep(value); //chachedValue
          if (target.Type.constructor === Function) {
            target.Type(value, path);
          } else {
            props = {};
            instanceVirtualVariables = {};
            instanceVirtualMethods = {};
            ref = target.instanceVirtualVariables;
            for (k in ref) {
              if (!hasProp.call(ref, k)) continue;
              ({attrType} = ref[k]);
              props[k] = attrType;
              instanceVirtualVariables[k] = attrType;
            }
            ref1 = target.instanceVirtualMethods;
            for (k in ref1) {
              if (!hasProp.call(ref1, k)) continue;
              ({attrType} = ref1[k]);
              props[k] = attrType;
              instanceVirtualMethods[k] = attrType;
            }
            if (instanceOf(value, CoreObject) && value.constructor.isSupersetOf(props)) {
              return value;
            }
            for (k in instanceVirtualVariables) {
              if (!hasProp.call(instanceVirtualVariables, k)) continue;
              attrType = instanceVirtualVariables[k];
              actual = value[k];
              createByType(attrType, actual, path.concat(`${k}: ${getTypeName(attrType)}`));
            }
            for (k in instanceVirtualMethods) {
              if (!hasProp.call(instanceVirtualMethods, k)) continue;
              attrType = instanceVirtualMethods[k];
              actual = value[k];
              createByType(attrType, actual, path.concat(`${k}: ${getTypeName(attrType)}`));
            }
          }
          return value;
        }
      });
      // Reflect.defineProperty Declare, 'cache',
      //   configurable: no
      //   enumerable: yes
      //   writable: no
      //   value: new Set()
      Reflect.defineProperty(Declare, 'cacheStrategy', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: SOFT
      });
      Reflect.defineProperty(Declare, 'ID', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: DeclareID
      });
      Module.prototype.SOFT_CACHE.set(DeclareID, new Set());
      Reflect.defineProperty(Declare, 'has', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: function(value) {
          return Module.prototype.SOFT_CACHE.get(DeclareID).has(value);
        }
      });
      Reflect.defineProperty(Declare, 'keep', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: function(value) {
          return Module.prototype.SOFT_CACHE.get(DeclareID).add(value);
        }
      });
      Reflect.defineProperty(Declare, 'name', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: name
      });
      Reflect.defineProperty(Declare, 'displayName', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: name
      });
      Reflect.defineProperty(Declare, 'define', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: function(spec) {
          var ref;
          if (Module.environment !== PRODUCTION) {
            assert(Module.prototype.TypeT.is(spec), `Invalid argument type ${assert.stringify(spec)} supplied to define(type) (expected a type)`);
            assert(_.isNil(Declare.Type), "Declare.define(type) can only be invoked once");
          }
          if (spec.constructor === Function) {
            if (spec.meta.kind === 'union' && Declare.hasOwnProperty('dispatch')) {
              spec.dispatch = Declare.dispatch;
            }
            Reflect.defineProperty(Declare, 'of', {
              configurable: false,
              enumerable: true,
              writable: false,
              value: (ref = spec.of) != null ? ref : function(x) {
                return x;
              }
            });
            Reflect.defineProperty(Declare, 'is', {
              configurable: false,
              enumerable: true,
              writable: false,
              value: spec.is
            });
            Reflect.setPrototypeOf(Declare.prototype, spec.prototype);
          } else {
            Reflect.defineProperty(spec, 'name', {
              value: Declare.name
            });
            Reflect.setPrototypeOf(Declare, spec);
            Reflect.setPrototypeOf(Declare.prototype, spec.prototype);
          }
          Reflect.defineProperty(Declare, 'meta', {
            configurable: false,
            enumerable: true,
            writable: false,
            value: spec.meta
          });
          Reflect.defineProperty(Declare, 'Type', {
            configurable: false,
            enumerable: true,
            writable: false,
            value: spec
          });
          return Declare;
        }
      });
      Reflect.defineProperty(Declare, 'meta', {
        configurable: true,
        enumerable: true,
        writable: false,
        value: {
          kind: 'declare',
          name: Declare.displayName,
          identity: true
        }
      });
      CACHE.set(Declare, DeclareID);
      return declare;
    }));
  };

}).call(this);
