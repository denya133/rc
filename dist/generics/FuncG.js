// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  module.exports = function(Module) {
    var CACHE, Generic, NON, PRODUCTION, _, assert, createByType, getTypeName, typesCache, uuid;
    ({
      PRODUCTION,
      CACHE,
      NON,
      Generic,
      Utils: {
        _,
        uuid,
        t: {assert},
        getTypeName,
        createByType
      }
    } = Module.prototype);
    typesCache = new Map();
    return Module.defineGeneric(Generic('FuncG', function(ArgsTypes, ReturnType) {
      var Func, FuncID, _ids, cachedType, displayName, domainLength, id, optionalArgumentsIndex;
      if (ArgsTypes == null) {
        ArgsTypes = [];
      }
      if (!_.isArray(ArgsTypes)) {
        ArgsTypes = [ArgsTypes];
      }
      if (ArgsTypes.length === 0 && (ReturnType == null)) {
        return Module.prototype.FunctionT;
      }
      _ids = [];
      ReturnType = ReturnType != null ? ReturnType : Module.prototype.MaybeG(Module.prototype.AnyT);
      ArgsTypes = ArgsTypes.map(function(Type) {
        var id, t;
        t = Module.prototype.AccordG(Type);
        if ((id = CACHE.get(t)) == null) {
          id = uuid.v4();
          CACHE.set(t, id);
        }
        _ids.push(id);
        return t;
      });
      ReturnType = Module.prototype.AccordG(ReturnType);
      if (Module.environment !== PRODUCTION) {
        assert(ArgsTypes.every(_.isFunction), `Invalid argument ArgsTypes ${assert.stringify(ArgsTypes)} supplied to FuncG(ArgsTypes, ReturnType) (expected an array of functions)`);
        assert(_.isFunction(ReturnType), `Invalid argument ReturnType ${assert.stringify(ReturnType)} supplied to FuncG(ArgsTypes, ReturnType) (expected a function)`);
      }
      displayName = `(${ArgsTypes.map(getTypeName).join(', ')}) => ${getTypeName(ReturnType)}`;
      if ((id = CACHE.get(ReturnType)) == null) {
        id = uuid.v4();
        CACHE.set(ReturnType, id);
      }
      _ids.push(id);
      FuncID = _ids.join();
      if ((cachedType = typesCache.get(FuncID)) != null) {
        return cachedType;
      }
      domainLength = ArgsTypes.length;
      optionalArgumentsIndex = Module.prototype.getOptionalArgumentsIndex(ArgsTypes);
      Func = function(value, path) {
        if (Module.environment === PRODUCTION) {
          return value;
        }
        Func.isNotSample(this);
        if (!(_.isFunction(value) && _.isPlainObject(value.instrumentation))) {
          return Func.of(value);
        }
        if (path == null) {
          path = [Func.displayName];
        }
        assert(Func.is(value), `Invalid value ${assert.stringify(value)} supplied to ${path.join('.')} (expected a function)`);
        return value;
      };
      Reflect.defineProperty(Func, 'name', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: displayName
      });
      Reflect.defineProperty(Func, 'displayName', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: displayName
      });
      Reflect.defineProperty(Func, 'is', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: function(x) {
          return _.isFunction(x) && _.isPlainObject(x.instrumentation) && x.instrumentation.domain.length === domainLength && x.instrumentation.domain.every(function(type, i) {
            return type === ArgsTypes[i];
          }) && x.instrumentation.codomain === ReturnType;
        }
      });
      Reflect.defineProperty(Func, 'of', {
        configurable: false,
        enumerable: true,
        writable: false,
        // value: (f, curried)->
        value: function(f) {
          var fn;
          if (Module.environment !== PRODUCTION) {
            assert(_.isFunction(f), `Invalid argument f supplied to FuncT ${displayName} (expected a function)`);
          }
          if (Func.is(f)) {
            // assert _.isNil(curried) or _.isBoolean(curried), "Invalid argument curried #{assert.stringify curried} supplied to FuncT #{displayName} (expected a boolean)"
            return f;
          }
          fn = function(...args) {
            var data, tupleLength;
            // argsLength = args.length
            if (Module.environment !== PRODUCTION) {
              tupleLength = optionalArgumentsIndex;
              // tupleLength = if curried
              //   argsLength
              // else
              //   # Math.max argsLength, optionalArgumentsIndex
              //   optionalArgumentsIndex
              if (domainLength !== 0) {
                if (typeof fn.argsTuple === "function") {
                  fn.argsTuple(args.slice(0, optionalArgumentsIndex), [`arguments of \`${fn.name}${displayName}\``]);
                }
              }
            }
            // if curried and domainLength > 0 and argsLength < domainLength
            //   if Module.environment isnt PRODUCTION
            //     assert argsLength > 0, 'Invalid arguments.length = 0 for curried function ' + displayName
            //   g = Function.prototype.bind.apply(f, [@].concat(args))
            //   newDomain = Module::FuncG(ArgsTypes.slice(argsLength), ReturnType)
            //   return newDomain.of g, yes
            // else
            data = f.apply(this, args);
            if (Module.environment !== PRODUCTION) {
              createByType(ReturnType, data, [`return of \`${fn.name}${displayName}\``]);
            }
            return data;
          };
          Reflect.defineProperty(fn, 'argsTuple', {
            configurable: false,
            enumerable: true,
            writable: false,
            value: (function() {
              if (domainLength !== 0) {
                return Module.prototype.TupleG(ArgsTypes.slice(0, optionalArgumentsIndex));
              }
            })()
          });
          Reflect.defineProperty(fn, 'instrumentation', {
            configurable: false,
            enumerable: true,
            writable: false,
            value: {
              domain: ArgsTypes,
              codomain: ReturnType,
              f
            }
          });
          Reflect.defineProperty(fn, 'name', {
            configurable: true,
            enumerable: true,
            writable: false,
            value: getTypeName(f)
          });
          Reflect.defineProperty(fn, 'displayName', {
            configurable: true,
            enumerable: true,
            writable: false,
            value: fn.name
          });
          return fn;
        }
      });
      Reflect.defineProperty(Func, 'meta', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: {
          kind: 'func',
          domain: ArgsTypes,
          codomain: ReturnType,
          name: Func.displayName,
          identity: true
        }
      });
      Reflect.defineProperty(Func, 'cacheStrategy', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: NON
      });
      Reflect.defineProperty(Func, 'isNotSample', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: Module.prototype.NotSampleG(Func)
      });
      typesCache.set(FuncID, Func);
      CACHE.set(Func, FuncID);
      return Func;
    }));
  };

}).call(this);
