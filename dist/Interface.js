// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.

  // смысл интерфейса, чтобы объявить публичные виртуальные методы (и/или) проперти
  // сами они должны быть реализованы в тех классах, куда подмешаны интерфейсы
  // !!! Вопрос: а надо ли указывать типы аргументов и возвращаемого значения в декларации методов в интерфейсе если эти методы виртуальные???????????
  // !!! Ответ: т.к. это интерфейсы дефиниции методов должны быть полностью задекларированы, чтобы реализации строго соотвествовали сигнатурам методов интерфейса.
  // если в интерфейсе объявлен тип выходного значения как AnyT то проверку можно сделать строже, объявив конкретный тип в реализации метода в самом классе.
  var hasProp = {}.hasOwnProperty;

  module.exports = function(Module) {
    var CACHE, CoreObject, Declare, Interface, PRODUCTION, VIRTUAL, _, assert, assign, createByType, getTypeName, instanceOf, isSubsetOf, t, valueIsType;
    ({
      PRODUCTION,
      CACHE,
      // WEAK
      VIRTUAL,
      Declare,
      CoreObject,
      Utils: {assign, _, t, getTypeName, createByType, valueIsType, isSubsetOf, instanceOf}
    } = Module.prototype);
    ({assert} = t);
    return Interface = (function() {
      var cpmDefineProperty;

      // cache = new Set()
      class Interface extends CoreObject {
        constructor() {
          super();
          if (this instanceof Interface) {
            assert.fail('new operator unsupported');
          }
        }

      };

      Interface.inheritProtected();

      Interface.module(Module);

      cpmDefineProperty = Symbol.for('~defineProperty');

      Interface.public(Interface.static({
        new: Function
      }, {
        default: function() {
          return assert.fail('new method unsupported for Interface');
        }
      }));

      Interface.public(Interface.static({
        implements: Function
      }, {
        default: function() {
          return assert.fail('implements method unsupported for Interface');
        }
      }));

      Interface.public(Interface.static({
        include: Function
      }, {
        default: function() {
          return assert.fail('include method unsupported for Interface');
        }
      }));

      Interface.public(Interface.static({
        initializeMixin: Function
      }, {
        default: function() {
          return assert.fail('initializeMixin method unsupported for Interface');
        }
      }));

      Interface.public(Interface.static({
        virtual: Function
      }, {
        default: function(...args) {
          var attr, attrType, config, isFunction, typeDefinition;
          assert(args.length > 0, 'arguments is required');
          [typeDefinition] = args;
          assert(_.isPlainObject(typeDefinition), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to virtual(typeDefinition) (expected a plain object or @static or/and @async definition)`);
          config = (typeDefinition.attr != null) && (typeDefinition.attrType != null) ? typeDefinition : (attr = Object.keys(typeDefinition)[0], attrType = typeDefinition[attr], attrType = this.Module.prototype.AccordG(attrType), isFunction = (attrType === this.Module.prototype.FunctionT || attrType === this.Module.prototype.GeneratorFunctionT) || this.Module.prototype.FunctorT.is(attrType), {attr, attrType, isFunction});
          config.level = VIRTUAL;
          return this[cpmDefineProperty](config);
        }
      }));

      Interface.public(Interface.static({
        initialize: Function
      }, {
        default: function() {
          // NOTE: т.к. CoreObject.initialize будет проверять нереализованные виртуальные методы, здесь ни в коем случае нельзя вызывать @super
          this.constructor = Module.prototype.Class;
          assert(_.isFunction(this.Module.const), `Module of ${this.name} must be subclass of RC::Module`);
          if (this.Module !== this || this.name === 'Module') {
            if ((this.Module.prototype[this.name] != null) && this.Module.prototype[this.name].meta.kind === 'declare') {
              this.Module.prototype[this.name].define(this);
            } else {
              Reflect.defineProperty(this, 'cache', {
                configurable: false,
                enumerable: true,
                writable: false,
                value: new Set()
              });
              // Reflect.defineProperty @, 'cacheStrategy',
              //   configurable: no
              //   enumerable: yes
              //   writable: no
              //   value: WEAK

              // Reflect.defineProperty @, 'ID',
              //   configurable: no
              //   enumerable: yes
              //   writable: no
              //   value: @name
              this.Module.const({
                [`${this.name}`]: new Proxy(this, {
                  apply: function(target, thisArg, argumentsList) {
                    var actual, attrType, instanceVirtualMethods, instanceVirtualVariables, k, path, props, ref, ref1, value;
                    [value, path] = argumentsList;
                    if (Module.environment === PRODUCTION) {
                      return value;
                    }
                    if (path == null) {
                      path = [target.name];
                    }
                    assert(value != null, `Invalid value ${assert.stringify(value)} supplied to ${path.join('.')}`);
                    if (target.cache.has(value)) {
                      return value;
                    }
                    target.cache.add(value);
                    props = {};
                    instanceVirtualVariables = {};
                    instanceVirtualMethods = {};
                    ref = target.instanceVirtualVariables;
                    for (k in ref) {
                      if (!hasProp.call(ref, k)) continue;
                      ({attrType} = ref[k]);
                      props[k] = attrType;
                      instanceVirtualVariables[k] = attrType;
                    }
                    ref1 = target.instanceVirtualMethods;
                    for (k in ref1) {
                      if (!hasProp.call(ref1, k)) continue;
                      ({attrType} = ref1[k]);
                      props[k] = attrType;
                      instanceVirtualMethods[k] = attrType;
                    }
                    if (instanceOf(value, CoreObject) && value.constructor.isSupersetOf(props)) {
                      return value;
                    }
                    for (k in instanceVirtualVariables) {
                      if (!hasProp.call(instanceVirtualVariables, k)) continue;
                      attrType = instanceVirtualVariables[k];
                      actual = value[k];
                      createByType(attrType, actual, path.concat(`${k}: ${getTypeName(attrType)}`));
                    }
                    for (k in instanceVirtualMethods) {
                      if (!hasProp.call(instanceVirtualMethods, k)) continue;
                      attrType = instanceVirtualMethods[k];
                      actual = value[k];
                      createByType(attrType, actual, path.concat(`${k}: ${getTypeName(attrType)}`));
                    }
                    return value;
                  }
                })
              });
              CACHE.set(this.Module.prototype[this.name], this.name);
            }
          }
          return this;
        }
      }));

      Interface.public(Interface.static({
        displayName: String
      }, {
        get: function() {
          return this.name;
        }
      }));

      Interface.public(Interface.static({
        is: Function
      }, {
        default: function(x) {
          var attrType, instanceVirtualMethods, instanceVirtualVariables, k, props, ref, ref1;
          if (x == null) {
            return false;
          }
          if (this.cache.has(x)) {
            return true;
          }
          props = {};
          instanceVirtualVariables = {};
          instanceVirtualMethods = {};
          ref = this.instanceVirtualVariables;
          for (k in ref) {
            if (!hasProp.call(ref, k)) continue;
            ({attrType} = ref[k]);
            props[k] = attrType;
            instanceVirtualVariables[k] = attrType;
          }
          ref1 = this.instanceVirtualMethods;
          for (k in ref1) {
            if (!hasProp.call(ref1, k)) continue;
            ({attrType} = ref1[k]);
            props[k] = attrType;
            instanceVirtualMethods[k] = attrType;
          }
          if (instanceOf(x, CoreObject) && x.constructor.isSupersetOf(props)) {
            this.cache.add(x);
            return true;
          }
          for (k in instanceVirtualVariables) {
            if (!hasProp.call(instanceVirtualVariables, k)) continue;
            attrType = instanceVirtualVariables[k];
            if (!valueIsType(x[k], attrType)) {
              return false;
            }
          }
          for (k in instanceVirtualMethods) {
            if (!hasProp.call(instanceVirtualMethods, k)) continue;
            if (!_.isFunction(x[k])) {
              return false;
            }
          }
          this.cache.add(x);
          return true;
        }
      }));

      Interface.public(Interface.static({
        meta: Object
      }, {
        get: function() {
          var attrType, classMethods, classVariables, instanceMethods, instanceVariables, k, ref, ref1, ref2, ref3;
          instanceVariables = {};
          instanceMethods = {};
          classVariables = {};
          classMethods = {};
          ref = this.instanceVirtualVariables;
          for (k in ref) {
            if (!hasProp.call(ref, k)) continue;
            ({attrType} = ref[k]);
            instanceVariables[k] = attrType;
          }
          ref1 = this.instanceVirtualMethods;
          for (k in ref1) {
            if (!hasProp.call(ref1, k)) continue;
            ({attrType} = ref1[k]);
            instanceMethods[k] = attrType;
          }
          ref2 = this.classVirtualVariables;
          for (k in ref2) {
            if (!hasProp.call(ref2, k)) continue;
            ({attrType} = ref2[k]);
            classVariables[k] = attrType;
          }
          ref3 = this.classVirtualMethods;
          for (k in ref3) {
            if (!hasProp.call(ref3, k)) continue;
            ({attrType} = ref3[k]);
            classMethods[k] = attrType;
          }
          return {
            kind: 'interface',
            statics: assign({}, classVariables, classMethods),
            props: assign({}, instanceVariables, instanceMethods),
            name: this.name,
            identity: true,
            strict: false
          };
        }
      }));

      Interface.initialize();

      return Interface;

    }).call(this);
  };

}).call(this);
