// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  module.exports = function(RC) {
    var _, arrayToPromise, co, isGenerator, isGeneratorFunction, isObject, isPromise, objectToPromise, thunkPromise, toPromise;
    ({_} = RC.prototype);
    toPromise = function(obj) {
      switch (false) {
        case !(obj == null):
          return obj;
        case !isPromise(obj):
          return obj;
        case !(isGeneratorFunction(obj) || isGenerator(obj)):
          return RC.prototype.Utils.co.call(this, obj);
        case !_.isFunction(obj):
          return thunkPromise.call(this, obj);
        case !_.isArray(obj):
          return arrayToPromise.call(this, obj);
        case !isObject(obj):
          return objectToPromise.call(this, obj);
        default:
          return RC.prototype.Promise.resolve(obj);
      }
    };
    thunkPromise = function(fn) {
      var context;
      context = this;
      return RC.prototype.Promise.new(function(resolve, reject) {
        return fn.call(context, function(err, ...res) {
          if (err != null) {
            reject(err);
          } else {
            resolve(res.length > 1 ? res : res[0]);
          }
        });
      });
    };
    arrayToPromise = function(obj) {
      return RC.prototype.Promise.all(obj.map(toPromise, this));
    };
    objectToPromise = function(obj) {
      var defer, i, key, keys, len, promise, promises, results;
      results = new obj.constructor();
      keys = Object.keys(obj);
      promises = [];
      defer = function(promise, key) {
        results[key] = void 0;
        return promises.push(promise.then(function(res) {
          results[key] = res;
        }));
      };
      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        promise = toPromise.call(this, obj[key]);
        if ((promise != null) && isPromise(promise)) {
          defer(promise, key);
        } else {
          results[key] = obj[key];
        }
      }
      return RC.prototype.Promise.all(promises).then(function() {
        return results;
      });
    };
    isPromise = RC.prototype.Utils.isThenable;
    isObject = _.isPlainObject;
    isGenerator = function(obj) {
      return _.isFunction(obj != null ? obj.next : void 0) && _.isFunction(obj != null ? obj.throw : void 0);
    };
    RC.util({
      isGenerator: isGenerator
    });
    isGeneratorFunction = function(obj) {
      var constructor;
      ({constructor} = obj);
      if (constructor == null) {
        return false;
      }
      if (constructor.name === 'GeneratorFunction' || constructor.displayName === 'GeneratorFunction') {
        return true;
      }
      return isGenerator(constructor.prototype);
    };
    RC.util({
      isGeneratorFunction: isGeneratorFunction
    });
    RC.util({
      co: co = function(generator, ...args) {
        var context;
        context = this;
        return RC.prototype.Promise.new(function(resolve, reject) {
          var next, onFulfilled, onRejected;
          if (_.isFunction(generator)) {
            generator = generator.apply(context, args);
          }
          if (!isGenerator(generator)) {
            return resolve(generator);
          }
          onFulfilled = function(res) {
            var e, ret;
            try {
              ret = generator.next(res);
            } catch (error) {
              e = error;
              return reject(e);
            }
            next(ret);
            return null;
          };
          onRejected = function(err) {
            var e, ret;
            try {
              ret = generator.throw(err);
            } catch (error) {
              e = error;
              return reject(e);
            }
            next(ret);
          };
          next = function(ret) {
            var value;
            if (ret != null ? ret.done : void 0) {
              return resolve(ret.value);
            }
            value = toPromise.call(context, ret.value);
            if ((value != null) && isPromise(value)) {
              return value.then(onFulfilled, onRejected);
            }
            return onRejected(new TypeError(`You may only yield a function, promise, generator, array, or object, but the following object was passed: '${String(ret.value)}'`));
          };
          onFulfilled();
        });
      }
    });
    co.wrap = function(fn) {
      var createPromise;
      createPromise = function(...args) {
        return RC.prototype.Utils.co.call(this, fn.apply(this, args));
      };
      createPromise.__generatorFunction__ = fn;
      return createPromise;
    };
    return co;
  };

}).call(this);
