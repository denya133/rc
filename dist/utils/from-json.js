// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  var hasProp = {}.hasOwnProperty;

  module.exports = function(Module) {
    var PRODUCTION, _, assert, createByType, fromJSON, getTypeName, instanceOf;
    ({
      PRODUCTION,
      Utils: {
        _,
        t: {assert},
        getTypeName,
        createByType,
        instanceOf
      }
    } = Module.prototype);
    return Module.util({
      fromJSON: fromJSON = function(value, type, path) {
        var aType, codomain, codomainName, domain, domainName, eType, k, ref, ret, types, v;
        if (Module.environment !== PRODUCTION) {
          assert(_.isFunction(type), `Invalid argument type ${assert.stringify(type)} supplied to fromJSON(value, type) (expected a type)`);
        }
        if (path == null) {
          path = [getTypeName(type)];
        }
        if (_.isFunction(type.fromJSON)) {
          return createByType(type, type.fromJSON(value), path);
        }
        if (!Module.prototype.TypeT.is(type)) {
          if (instanceOf(value, type)) {
            return value;
          } else {
            return new type(value);
          }
        }
        switch (type.meta.kind) {
          case 'maybe':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              if (value != null) {
                fromJSON(value, type.meta.type, path);
              }
              return value;
            }
            break;
          case 'subtype':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              ret = fromJSON(value, type.meta.type, path);
              assert(type.meta.predicate(ret), `Invalid argument value ${assert.stringify(value)} supplied to fromJSON(value, type) (expected a valid ${getTypeName(type)})`);
              return value;
            }
            break;
          case 'interface':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              assert(_.isPlainObject(value), `Invalid argument value ${assert.stringify(value)} supplied to fromJSON(value, type) (expected an object)`);
              ref = type.meta.props;
              for (k in ref) {
                if (!hasProp.call(ref, k)) continue;
                v = ref[k];
                fromJSON(value[k], v, path.concat(`${k}: ${getTypeName(v)}`));
              }
              return value;
            }
            break;
          case 'list':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              assert(_.isArray(value), `Invalid argument value ${assert.stringify(value)} supplied to fromJSON(value, type) (expected an array for type ${getTypeName(type)})`);
              eType = type.meta.type;
              value.forEach(function(e, i) {
                return fromJSON(e, eType, path.concat(`${i}: ${getTypeName(eType)}`));
              });
              return value;
            }
            break;
          case 'union':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              aType = type.dispatch(value);
              assert(_.isFunction(aType), `Invalid argument value ${assert.stringify(value)} supplied to fromJSON(value, type) (no constructor returned by dispatch of union ${getTypeName(type)})`);
              fromJSON(value, actualType, path);
              return value;
            }
            break;
          case 'tuple':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              assert(_.isArray(value), `Invalid argument value ${assert.stringify(value)} supplied to fromJSON(value, type) (expected an array for type ${getTypeName(type)})`);
              types = type.meta.types;
              assert(_.isArray(value) && value.length === types.length, `Invalid value ${assert.stringify(value)} supplied to fromJSON(value, type) (expected an array of length ${types.length} for type ${getTypeName(type)})`);
              value.forEach(function(e, i) {
                return fromJSON(e, types[i], path.concat(`${i}: ${getTypeName(types[i])}`));
              });
              return value;
            }
            break;
          case 'dict':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              assert(_.isPlainObject(value), `Invalid argument value ${assert.stringify(value)} supplied to fromJSON(value, type) (expected an object for type ${getTypeName(type)})`);
              ({domain, codomain} = type.meta);
              domainName = getTypeName(domain);
              codomainName = getTypeName(codomain);
              for (k in value) {
                if (!hasProp.call(value, k)) continue;
                v = value[k];
                domain(k, path.concat(domainName));
                fromJSON(v, codomain, path.concat(`${k}: ${codomainName}`));
              }
              return value;
            }
            break;
          case 'intersection':
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              type.meta.types.forEach(function(type, i) {
                return fromJSON(value, type, path.concat(`${i}: ${getTypeName(type)}`));
              });
              type(value, path);
              return value; // enums, irreducible
            }
            break;
          default:
            // NOTE: func, map, set sample тоже могли бы попасть сюда, НО они не могут прийти из JSON'а, т.к. могут существовать только в оперативной памяти
            if (Module.environment === PRODUCTION) {
              return value;
            } else {
              type(value, path);
              return value;
            }
        }
      }
    });
  };

}).call(this);
