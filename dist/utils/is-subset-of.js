// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  var indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;

  module.exports = function(Module) {
    var CACHE, PRODUCTION, _, assert, createByType, decompose, find, getPredicates, getTypeName, getUnrefinedType, index, isRefinement, leq, leqArguments, leqList, leqPredicates, put, recurse, resultsCache;
    ({
      PRODUCTION,
      CACHE,
      Utils: {
        _,
        // uuid
        t: {assert},
        getTypeName,
        createByType
      }
    } = Module.prototype);
    isRefinement = function(type) {
      return Module.prototype.TypeT.is(type) && type.meta.kind === 'subtype';
    };
    getPredicates = function(type) {
      if (isRefinement(type)) {
        return [type.meta.predicate].concat(getPredicates(type.meta.type));
      } else {
        return [];
      }
    };
    getUnrefinedType = function(type) {
      if (isRefinement(type)) {
        return getUnrefinedType(type.meta.type);
      } else {
        return type;
      }
    };
    decompose = function(type) {
      return {
        predicates: getPredicates(type),
        unrefinedType: getUnrefinedType(type)
      };
    };
    leqArguments = function(As, Bs) {
      return Bs.length <= As.length && Bs.every(function(B, i) {
        return recurse(As[i], B);
      });
    };
    leqList = function(As, Bs) {
      return As.length === Bs.length && As.every(function(A, i) {
        return recurse(A, Bs[i]);
      });
    };
    leqPredicates = function(ps1, ps2) {
      return ps2.length <= ps1.length && ps2.every(function(p) {
        return indexOf.call(ps1, p) >= 0;
      });
    };
    index = new Map(); //[]
    find = function(A, B) {
      var ref;
      return (ref = index.get(B)) != null ? ref.get(A) : void 0;
    };
    // for item in index when item.A is A and item.B is B
    //   return item
    put = function(A, B, hit) {
      var subIndex;
      subIndex = index.get(B);
      if (subIndex == null) {
        subIndex = (function() {
          var _si;
          _si = new Map();
          index.set(B, _si);
          return _si;
        })();
      }
      subIndex.set(A, hit);
    };
    leq = function(A, B) {
      var compatible, dA, dB, gte, keysB, kindA, kindB, staticsB;
      // Fast results
      // (1) if B === t.Any then A <= B for all A
      // (2) if B === A then A <= B for all A
      if (A === B || (B === Module.prototype.AnyT && A !== Module.prototype.NilT)) {
        return true;
      }
      kindA = A.meta.kind;
      kindB = B.meta.kind;
      // Reductions

      // (3) if B = maybe(C) and A is not a maybe then A <= B if and only if A === t.Nil or A <= C
      if (kindB === 'maybe' && kindA !== 'maybe') {
        return (A === Module.prototype.NilT) || recurse(A, B.meta.type);
      }
      gte = function(type) {
        return recurse(A, type);
      };
      // (4) if B is a union then A <= B if exists B' in B.meta.types such that A <= B'
      if (kindB === 'union') {
        if (B.meta.types.some(gte)) {
          return true;
        }
      }
      if (kindB === 'subset' && kindA !== 'subset') {
        return A === B.meta.type || recurse(A, B.meta.type);
      }
      // (5) if B is an intersection then A <= B if A <= B' for all B' in B.meta.types
      if (kindB === 'intersection') {
        if (B.meta.types.every(gte)) {
          return true;
        }
      }
      // Let A be a maybe then A <= B if B is a maybe and A.meta.type <= B.meta.type
      if (kindA === 'maybe') {
        return kindB === 'maybe' && recurse(A.meta.type, B.meta.type);
      // Let A be an union then A <= B if A' <= B for all A' in A.meta.types
      } else if (kindA === 'union') {
        return A.meta.types.every(function(T) {
          return recurse(T, B);
        });
      // Let A be an intersection then A <= B if exists A' in A.meta.types such that A' <= B
      } else if (kindA === 'intersection') {
        return A.meta.types.some(function(T) {
          return recurse(T, B);
        });
      // Let A be irreducible then A <= B if B is irreducible and A.is === B.is
      } else if (kindA === 'irreducible') {
        return kindB === 'irreducible' && A.meta.predicate === B.meta.predicate;
      } else if (kindA === 'sample') {
        return kindB === 'sample' && (A.meta.type === B.meta.type || (function(a) {
          while (a = Reflect.getPrototypeOf(a)) {
            if (a === B.meta.type) {
              return true;
            }
          }
          return false;
        })(A.meta.type));
      } else if (kindA === 'not-sample') {
        return kindB === 'not-sample' && (A.meta.type === B.meta.type || !(function(a) {
          while (a = Reflect.getPrototypeOf(a)) {
            if (a === B.meta.type) {
              return true;
            }
          }
          return false;
        })(A.meta.type));
      } else if (kindA === 'subset') {
        return kindB === 'subset' && (A.meta.type === B.meta.type || recurse(A.meta.type, B.meta.type));
      // Let A be an enum then A <= B if and only if B.is(a) === true for all a in keys(A.meta.map)
      } else if (kindA === 'enums') {
        return Object.keys(A.meta.map.values()).every(B.is);
      // Let A be a refinement then A <= B if decompose(A) <= decompose(B)
      } else if (kindA === 'subtype') {
        dA = decompose(A);
        dB = decompose(B);
        return leqPredicates(dA.predicates, dB.predicates) && recurse(dA.unrefinedType, dB.unrefinedType);
      // Let A be a list then A <= B if one of the following holds:
      } else if (kindA === 'list') {
        // B === t.Array
        if (B === Module.prototype.ArrayT || B === Module.prototype.ListT) {
          return true;
        }
        // B is a list and A.meta.type <= B.meta.type
        return kindB === 'list' && recurse(A.meta.type, B.meta.type);
      // Let A be a set then A <= B if one of the following holds:
      } else if (kindA === 'set') {
        // B === SetT
        if (B === Module.prototype.SetT) {
          return true;
        }
        // B is a list and A.meta.type <= B.meta.type
        return kindB === 'set' && recurse(A.meta.type, B.meta.type);
      // Let A be a list then A <= B if one of the following holds:
      } else if (kindA === 'dict') {
        // B === t.Object
        if (B === Module.prototype.ObjectT || B === Module.prototype.DictT) {
          return true;
        }
        // B is a dictionary and [A.meta.domain, A.meta.codomain] <= [B.meta.domain, B.meta.codomain]
        return kindB === 'dict' && recurse(A.meta.domain, B.meta.domain) && recurse(A.meta.codomain, B.meta.codomain);
      // Let A be a map then A <= B if one of the following holds:
      } else if (kindA === 'map') {
        // B === MapT
        if (B === Module.prototype.MapT) {
          return true;
        }
        // B is a dictionary and [A.meta.domain, A.meta.codomain] <= [B.meta.domain, B.meta.codomain]
        return kindB === 'map' && recurse(A.meta.domain, B.meta.domain) && recurse(A.meta.codomain, B.meta.codomain);
      // Let A be a tuple then A <= B if one of the following holds:
      } else if (kindA === 'tuple') {
        // B === t.Array
        if (B === Module.prototype.ArrayT || B === Module.prototype.TupleT) {
          return true;
        }
        // B is a tuple and A.meta.types <= B.meta.types
        return kindB === 'tuple' && leqList(A.meta.types, B.meta.types);
      // Let A be a function then A <= B if one of the following holds:
      } else if (kindA === 'func') {
        // B === t.Function
        if (B === Module.prototype.FunctionT) {
          return true;
        }
        // B is a function and [A.meta.domain, A.meta.codomain] <= [B.meta.domain, B.meta.codomain]
        return kindB === 'func' && recurse(A.meta.codomain, B.meta.codomain) && leqArguments(A.meta.domain, B.meta.domain);
      // Let A be a async function then A <= B if one of the following holds:
      } else if (kindA === 'async') {
        // B === t.Function
        if (B === Module.prototype.FunctionT) {
          return true;
        }
        // B is a function and [A.meta.domain, A.meta.codomain] <= [B.meta.domain, B.meta.codomain]
        return kindB === 'async' && recurse(A.meta.codomain, B.meta.codomain) && leqArguments(A.meta.domain, B.meta.domain);
      // Let A be a generic then A <= B if one of the following holds:
      } else if (kindA === 'generic') {
        // B === t.Function
        if (B === Module.prototype.FunctionT || B === Module.prototype.GenericT) {
          return true;
        }
        return false;
      // Let A be a mixin then A <= B if one of the following holds:
      } else if (kindA === 'mixin') {
        // B === t.Function
        if (B === Module.prototype.FunctionT || B === Module.prototype.MixinT) {
          return true;
        }
        return false;
      // Let A be a module then A <= B if one of the following holds:
      } else if (kindA === 'module') {
        // B === t.Function
        if (B === Module.prototype.FunctionT || B === Module.prototype.ModuleT) {
          return true;
        }
        if (kindB === 'interface') {
          if (B.meta.statics == null) {
            return false; // when B created by InterfaceG
          }
          return (function() {
            var attrType, classProps, instanceProps, k, keysB, ref, ref1, ref2, ref3, staticsB;
            instanceProps = {};
            classProps = {};
            ref = A.instanceVariables;
            for (k in ref) {
              if (!hasProp.call(ref, k)) continue;
              ({attrType} = ref[k]);
              instanceProps[k] = attrType;
            }
            ref1 = A.instanceMethods;
            for (k in ref1) {
              if (!hasProp.call(ref1, k)) continue;
              ({attrType} = ref1[k]);
              instanceProps[k] = attrType;
            }
            ref2 = A.classVariables;
            for (k in ref2) {
              if (!hasProp.call(ref2, k)) continue;
              ({attrType} = ref2[k]);
              classProps[k] = attrType;
            }
            ref3 = A.classMethods;
            for (k in ref3) {
              if (!hasProp.call(ref3, k)) continue;
              ({attrType} = ref3[k]);
              classProps[k] = attrType;
            }
            keysB = Object.keys(B.meta.props);
            staticsB = Object.keys(B.meta.statics);
            return keysB.every(function(k) {
              return instanceProps.hasOwnProperty(k) && recurse(instanceProps[k], B.meta.props[k]);
            }) && staticsB.every(function(k) {
              return classProps.hasOwnProperty(k) && recurse(classProps[k], B.meta.statics[k]);
            });
          })();
        }
        if (!Module.prototype.ModuleT.is(B)) {
          return false;
        }
        return (function(a) {
          while (a = Reflect.getPrototypeOf(a)) {
            if (a === B) {
              return true;
            }
          }
          return false;
        })(A);
      // Let A be a class then A <= B if one of the following holds:
      } else if (kindA === 'class') {
        // B === t.Function
        if (B === Module.prototype.FunctionT || B === Module.prototype.ClassT) {
          return true;
        }
        if (kindB === 'interface') {
          if (B.meta.statics == null) {
            return false; // when B created by InterfaceG
          }
          return (function() {
            var attrType, classProps, instanceProps, k, keysB, ref, ref1, ref2, ref3, staticsB;
            instanceProps = {};
            classProps = {};
            ref = A.instanceVariables;
            for (k in ref) {
              if (!hasProp.call(ref, k)) continue;
              ({attrType} = ref[k]);
              instanceProps[k] = attrType;
            }
            ref1 = A.instanceMethods;
            for (k in ref1) {
              if (!hasProp.call(ref1, k)) continue;
              ({attrType} = ref1[k]);
              instanceProps[k] = attrType;
            }
            ref2 = A.classVariables;
            for (k in ref2) {
              if (!hasProp.call(ref2, k)) continue;
              ({attrType} = ref2[k]);
              classProps[k] = attrType;
            }
            ref3 = A.classMethods;
            for (k in ref3) {
              if (!hasProp.call(ref3, k)) continue;
              ({attrType} = ref3[k]);
              classProps[k] = attrType;
            }
            keysB = Object.keys(B.meta.props);
            staticsB = Object.keys(B.meta.statics);
            return keysB.every(function(k) {
              return instanceProps.hasOwnProperty(k) && recurse(instanceProps[k], B.meta.props[k]);
            }) && staticsB.every(function(k) {
              return classProps.hasOwnProperty(k) && recurse(classProps[k], B.meta.statics[k]);
            });
          })();
        }
        if (!Module.prototype.ClassT.is(B)) {
          return false;
        }
        return (function(a) {
          while (a = Reflect.getPrototypeOf(a)) {
            if (a === B) {
              return true;
            }
          }
          return false;
        })(A);
      // Let A be an interface then A <= B if one of the following holds:
      } else if (kindA === 'interface' || kindA === 'struct') {
        // B === t.Object
        if (B === Module.prototype.ObjectT || B === Module.prototype.InterfaceT) {
          return true;
        }
        if (kindB === 'interface') {
          keysB = Object.keys(B.meta.props);
          compatible = keysB.every(function(k) {
            return A.meta.props.hasOwnProperty(k) && recurse(A.meta.props[k], B.meta.props[k]);
          });
          if (B.meta.statics != null) {
            staticsB = Object.keys(B.meta.statics);
            compatible && (compatible = staticsB.every(function(k) {
              return A.meta.statics.hasOwnProperty(k) && recurse(A.meta.statics[k], B.meta.statics[k]);
            }));
          }
          // B is an interface, B.meta.strict === no, keys(B.meta.props) <= keys(A.meta.props) and A.meta.props[k] <= B.meta.props[k] for all k in keys(B.meta.props)
          if (B.meta.strict === false) {
            return compatible;
          }
          // B is an interface, B.meta.strict === true, A.meta.strict === true, keys(B.meta.props) = keys(A.meta.props) and A.meta.props[k] <= B.meta.props[k] for all k in keys(B.meta.props)
          return compatible && A.meta.strict === true && keysB.length === Object.keys(A.meta.props).length;
        }
      }
      return false;
    };
    recurse = function(A, B) {
      var hit;
      // handle recursive types
      if ((hit = find(A, B)) != null) {
        return hit.leq;
      }
      hit = {
        A,
        B,
        leq: true
      };
      put(A, B, hit);
      hit.leq = leq(A, B);
      return hit.leq;
    };
    resultsCache = new Map();
    return Module.util({
      isSubsetOf: function(A, B) {
        var ID, _ids, cachedResult, result;
        if (Module.environment === PRODUCTION) {
          return true;
        }
        _ids = [CACHE.get(A), CACHE.get(B)];
        // unless (id = CACHE.get A)?
        //   id = uuid.v4()
        //   CACHE.set A, id
        // _ids.push id
        // unless (id = CACHE.get B)?
        //   id = uuid.v4()
        //   CACHE.set B, id
        // _ids.push id
        ID = _ids.join();
        if ((cachedResult = resultsCache.get(ID)) != null) {
          return cachedResult;
        }
        assert(_.isFunction(A) && _.isPlainObject(A.meta), `Invalid argument subset ${assert.stringify(A)} supplied to isSubsetOf(subset, superset) (expected a type)`);
        assert(_.isFunction(B) && _.isPlainObject(B.meta), `Invalid argument superset ${assert.stringify(B)} supplied to isSubsetOf(subset, superset) (expected a type)`);
        result = recurse(A, B);
        resultsCache.set(ID, result);
        return result;
      }
    });
  };

}).call(this);
