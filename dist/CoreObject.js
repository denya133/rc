// Generated by CoffeeScript 2.5.1
(function() {
  // This file is part of RC.

  // RC is free software: you can redistribute it and/or modify
  // it under the terms of the GNU Lesser General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // RC is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU Lesser General Public License for more details.

  // You should have received a copy of the GNU Lesser General Public License
  // along with RC.  If not, see <https://www.gnu.org/licenses/>.
  var hasProp = {}.hasOwnProperty;

  /*
  Пример инклуда для CoffeeScript 2.x
  class CoreObject
    size: ->
      8
    @include: (aMixin)->
      SuperClass = Object.getPrototypeOf @
      vMixin = aMixin SuperClass
      Object.setPrototypeOf @, vMixin
      Object.setPrototypeOf @::, vMixin::
      return

  _ControllerMixin = (Base)->
    class ControllerMixin extends Base
      size: ->
        super() + 4
      @size: ->
        66

  _Controller1Mixin = (Base)->
    class Controller1Mixin extends Base
      size: ->
        super() + 1

  class CucumberController extends CoreObject
    @include _ControllerMixin
    @include _Controller1Mixin

  cu = new CucumberController()
  console.log cu.size()
  console.log CucumberController.size()
  console.log CucumberController, cu
  */
  /*
  RC = require 'RC'
  {AnyT} = RC::

  module.exports = (App)->
    class App::TestInterface extends RC::Interface
      @inheritProtected()

      @Module: App

   * only public virtual properties and methods
      @public @static @virtual new: Function,
        args: [String, Object]
        return: Object
      @public @static @virtual create: Function,
        args: AnyT
        return: AnyT
      @public @virtual testing: Function,
        args: [Object, RC::Class, Boolean, String, Function]
        return: AnyT
    App::TestInterface.initialize()
   */
  /*
  RC = require 'RC'

  module.exports = (App)->
    class App::TestMixin extends RC::Mixin
      @inheritProtected()

      @Module: App

      @public methodInMixin: Function,
        args: [String, Object]
        return: Object
        default: (asPath, ahConfig)-> #some code

    App::TestMixin.initialize()
  */
  /*
  RC = require 'RC'

  module.exports = (App)->
    class App::Test extends RC::CoreObject
      @inheritProtected()
      @implements App::TestInterface
      @include App::TestMixin

      @Module: App

      ipnTestIt = @private testIt: Number,
        default: 9
        get: (anValue)-> anValue
        set: (anValue)->
          @send 'testItChanged', anValue
          anValue + 98

      ipcModel = @protected Model: RC::Class,
        default: Basis::User

      @public @static new: Function,
        default: (args...)->
          @super args...
          #some code
      @public @static create: Function,
        default: (args...)-> @::[ipcModel].new args...

      @public testing: Function,
        default: (ahConfig, alUsers, isInternal, asPath, lambda)->
          vhResult = @methodInMixin path, config
          #some code
    App::Test.initialize()
   */
  module.exports = function(RC) {
    var ASYNC, CACHE, CONST, PRIVATE, PRODUCTION, PROTECTED, PUBLIC, STATIC, VIRTUAL, WEAK, _, assert, ref, ref1, t;
    ({PRODUCTION, VIRTUAL, STATIC, ASYNC, CONST, PUBLIC, PRIVATE, PROTECTED, CACHE, WEAK} = RC.prototype);
    _ = (ref = RC.prototype._) != null ? ref : RC.prototype.Utils._;
    t = (ref1 = RC.prototype.t) != null ? ref1 : RC.prototype.Utils.t;
    ({assert} = t);
    RC.prototype.CoreObject = (function() {
      var CLASS_KEYS, INSTANCE_KEYS, cplExtensibles, cpmDefineProperty, cpoMetaObject, cpsExtensibleSymbol;

      class CoreObject {
        constructor(...args) {
          this.init(...args);
        }

      };

      CLASS_KEYS = ['arguments', 'name', 'displayName', 'caller', 'length', 'prototype', 'constructor', '__super__', 'including'];

      INSTANCE_KEYS = [
        'constructor',
        '__proto__',
        // 'length',
        'arguments',
        'caller'
      ];

      cpmDefineProperty = Symbol.for('~defineProperty');

      cplExtensibles = Symbol.for('~isExtensible');

      cpsExtensibleSymbol = Symbol.for('~extensibleSymbol');

      cpoMetaObject = Symbol.for('~metaObject');

      Reflect.defineProperty(CoreObject, cpoMetaObject, {
        enumerable: false,
        configurable: true,
        value: new RC.prototype.MetaObject(CoreObject)
      });

      Reflect.defineProperty(CoreObject, cplExtensibles, {
        enumerable: false,
        configurable: false,
        value: {}
      });

      Reflect.defineProperty(CoreObject, cpsExtensibleSymbol, {
        enumerable: false,
        configurable: true,
        value: Symbol('extensibleSymbol')
      });

      Reflect.defineProperty(CoreObject, 'isExtensible', {
        enumerable: true,
        configurable: false,
        get: function() {
          return this[cplExtensibles][this[cpsExtensibleSymbol]];
        }
      });

      // Core class API
      Reflect.defineProperty(CoreObject, 'super', {
        enumerable: true,
        value: function() {
          var SuperClass, caller, method, methodName, ref2, ref3, vClass;
          ({caller} = arguments.callee);
          vClass = (ref2 = caller.class) != null ? ref2 : this;
          SuperClass = Reflect.getPrototypeOf(vClass);
          methodName = (ref3 = caller.pointer) != null ? ref3 : caller.name;
          method = SuperClass != null ? SuperClass[methodName] : void 0;
          return method != null ? method.apply(this, arguments) : void 0;
        }
      });

      Reflect.defineProperty(CoreObject.prototype, 'super', {
        enumerable: true,
        value: function() {
          var SuperClass, caller, method, methodName, ref2, ref3, ref4, vClass;
          ({caller} = arguments.callee);
          vClass = (ref2 = caller.class) != null ? ref2 : this.constructor;
          SuperClass = Reflect.getPrototypeOf(vClass);
          methodName = (ref3 = caller.pointer) != null ? ref3 : caller.name;
          method = (ref4 = SuperClass.prototype) != null ? ref4[methodName] : void 0;
          return method != null ? method.apply(this, arguments) : void 0;
        }
      });

      Reflect.defineProperty(CoreObject, 'wrap', {
        enumerable: true,
        value: function(lambda) {
          var caller, ref2, vcClass, vsName, vsPointer, wrapper;
          ({caller} = arguments.callee);
          vcClass = (ref2 = caller.class) != null ? ref2 : this;
          vsName = caller.name;
          vsPointer = caller.pointer;
          wrapper = (...args) => {
            return lambda.apply(this, args);
          };
          Reflect.defineProperty(wrapper, 'class', {
            value: vcClass,
            enumerable: true
          });
          Reflect.defineProperty(lambda, 'class', {
            value: vcClass,
            enumerable: true
          });
          Reflect.defineProperty(wrapper, 'name', {
            value: vsName,
            configurable: true
          });
          Reflect.defineProperty(lambda, 'name', {
            value: vsName,
            configurable: true
          });
          Reflect.defineProperty(wrapper, 'pointer', {
            value: vsPointer,
            configurable: true,
            enumerable: true
          });
          Reflect.defineProperty(lambda, 'pointer', {
            value: vsPointer,
            configurable: true,
            enumerable: true
          });
          Reflect.defineProperty(lambda, 'wrapper', {
            value: wrapper,
            enumerable: true
          });
          Reflect.defineProperty(wrapper, 'body', {
            value: lambda,
            enumerable: true
          });
          return wrapper;
        }
      });

      Reflect.defineProperty(CoreObject.prototype, 'wrap', {
        enumerable: true,
        value: function(lambda) {
          var caller, ref2, vcClass, vsName, vsPointer, wrapper;
          ({caller} = arguments.callee);
          vcClass = (ref2 = caller.class) != null ? ref2 : this.constructor;
          vsName = caller.name;
          vsPointer = caller.pointer;
          wrapper = (...args) => {
            return lambda.apply(this, args);
          };
          Reflect.defineProperty(wrapper, 'class', {
            value: vcClass,
            enumerable: true
          });
          Reflect.defineProperty(lambda, 'class', {
            value: vcClass,
            enumerable: true
          });
          Reflect.defineProperty(wrapper, 'name', {
            value: vsName,
            configurable: true
          });
          Reflect.defineProperty(lambda, 'name', {
            value: vsName,
            configurable: true
          });
          Reflect.defineProperty(wrapper, 'pointer', {
            value: vsPointer,
            configurable: true,
            enumerable: true
          });
          Reflect.defineProperty(lambda, 'pointer', {
            value: vsPointer,
            configurable: true,
            enumerable: true
          });
          Reflect.defineProperty(lambda, 'wrapper', {
            value: wrapper,
            enumerable: true
          });
          Reflect.defineProperty(wrapper, 'body', {
            value: lambda,
            enumerable: true
          });
          return wrapper;
        }
      });

      Reflect.defineProperty(CoreObject, 'metaObject', {
        enumerable: true,
        configurable: true,
        get: function() {
          return this[cpoMetaObject];
        }
      });

      CoreObject[cplExtensibles][CoreObject[cpsExtensibleSymbol]] = true;

      Reflect.defineProperty(CoreObject, 'inheritProtected', {
        enumerable: true,
        value: function(abNormal = true) {
          var parent, ref2, ref3, self, superclass;
          self = this;
          superclass = (ref2 = this.superclass()) != null ? ref2 : {};
          parent = abNormal ? (ref3 = self.metaObject) != null ? ref3 : superclass.metaObject : superclass.metaObject;
          Reflect.defineProperty(self, cpoMetaObject, {
            enumerable: false,
            configurable: true,
            value: new RC.prototype.MetaObject(self, parent)
          });
          Reflect.defineProperty(self, cpsExtensibleSymbol, {
            enumerable: false,
            configurable: true,
            value: Symbol(`extensibleSymbol|${self.name}`)
          });
          self[cplExtensibles][self[cpsExtensibleSymbol]] = true;
        }
      });

      Reflect.defineProperty(CoreObject, 'new', {
        enumerable: true,
        configurable: true,
        value: function(...args) {
          return Reflect.construct(this, args);
        }
      });

      Reflect.defineProperty(CoreObject, 'include', {
        enumerable: true,
        value: function(...mixins) {
          if (Array.isArray(mixins[0])) {
            mixins = mixins[0];
          }
          mixins.forEach((mixin) => {
            var Mixin, SuperClass, ref2;
            assert(mixin != null, 'Supplied mixin was not found');
            assert(_.isFunction(mixin), 'Mixin must be a function');
            SuperClass = Reflect.getPrototypeOf(this);
            Mixin = mixin(SuperClass);
            Reflect.defineProperty(Mixin, 'name', {
              value: mixin.name
            });
            Reflect.setPrototypeOf(this, Mixin);
            Reflect.setPrototypeOf(this.prototype, Mixin.prototype);
            if ((ref2 = Mixin.including) != null) {
              ref2.call(this);
            }
            this.inheritProtected(false);
            return this.metaObject.addMetaData('mixins', mixin.name, mixin);
          });
          return this;
        }
      });

      Reflect.defineProperty(CoreObject, 'implements', {
        enumerable: true,
        value: function(...interfaces) {
          var classVirtualMethods, classVirtualVariables, instanceVirtualMethods, instanceVirtualVariables;
          if (Array.isArray(interfaces[0])) {
            interfaces = interfaces[0];
          }
          ({classVirtualVariables, classVirtualMethods, instanceVirtualVariables, instanceVirtualMethods} = this);
          interfaces.forEach((iface) => {
            var config, k, ref2, ref3, ref4, ref5, ref6;
            ref2 = iface.classVirtualVariables;
            for (k in ref2) {
              if (!hasProp.call(ref2, k)) continue;
              config = ref2[k];
              if (classVirtualVariables[k] == null) {
                this.metaObject.addMetaData('classVirtualVariables', k, config);
              }
            }
            ref3 = iface.classVirtualMethods;
            for (k in ref3) {
              if (!hasProp.call(ref3, k)) continue;
              config = ref3[k];
              if (classVirtualMethods[k] == null) {
                this.metaObject.addMetaData('classVirtualMethods', k, config);
              }
            }
            ref4 = iface.instanceVirtualVariables;
            for (k in ref4) {
              if (!hasProp.call(ref4, k)) continue;
              config = ref4[k];
              if (instanceVirtualVariables[k] == null) {
                this.metaObject.addMetaData('instanceVirtualVariables', k, config);
              }
            }
            ref5 = iface.instanceVirtualMethods;
            for (k in ref5) {
              if (!hasProp.call(ref5, k)) continue;
              config = ref5[k];
              if (instanceVirtualMethods[k] == null) {
                this.metaObject.addMetaData('instanceVirtualMethods', k, config);
              }
            }
            ref6 = iface.constants;
            for (k in ref6) {
              if (!hasProp.call(ref6, k)) continue;
              config = ref6[k];
              this[cpmDefineProperty](config);
            }
            return this.metaObject.addMetaData('interfaces', iface.name, iface);
          });
          return this;
        }
      });

      Reflect.defineProperty(CoreObject, 'freeze', {
        enumerable: true,
        configurable: false,
        value: function() {
          this[cplExtensibles][this[cpsExtensibleSymbol]] = false;
          return this;
        }
      });

      Reflect.defineProperty(CoreObject, 'isSupersetOf', {
        enumerable: true,
        configurable: false,
        value: function(props) {
          var attrType, config, instanceMethods, instanceVariables, key, ref2, ref3, result, type;
          assert(_.isPlainObject(props), 'Argument of `isSupersetOf` must be plain object with types definitions');
          if (((ref2 = this.Module) != null ? (ref3 = ref2.prototype) != null ? ref3.isSubsetOf : void 0 : void 0) == null) {
            return true;
          }
          ({instanceVariables, instanceMethods} = this);
          result = false;
          for (key in props) {
            if (!hasProp.call(props, key)) continue;
            type = props[key];
            if ((config = instanceVariables[key]) != null) {
              ({attrType} = config);
            } else if ((config = instanceMethods[key]) != null) {
              ({attrType} = config);
            } else {
              break;
            }
            result = this.Module.prototype.isSubsetOf(type, attrType);
            if (!result) {
              break;
            }
          }
          return result;
        }
      });

      Reflect.defineProperty(CoreObject, 'subtypeOf', {
        enumerable: true,
        configurable: false,
        value: function(attr, kind, member, Type, ParentType) {
          var ParentTypes, isMethod, isStatic, ref2, ref3;
          if (Type == null) {
            return;
          }
          if (ParentType == null) {
            return;
          }
          if (((ref2 = this.Module) != null ? (ref3 = ref2.prototype) != null ? ref3.isSubsetOf : void 0 : void 0) == null) {
            return;
          }
          isStatic = kind === 'static';
          isMethod = member === 'method';
          ParentTypes = _.castArray(ParentTypes);
          assert(this.Module.prototype.isSubsetOf(Type, ParentType), `Type definition ${this.Module.prototype.getTypeName(Type)} must be subset of ${this.name}${isStatic ? '.' : '::'}${attr}${isMethod ? '' : ': '}${this.Module.prototype.getTypeName(ParentType)}`);
          if (kind === 'static') {
            if (member === 'method') {
              this.metaObject.addMetaData('classImplemenedMethods', attr, true);
            } else {
              this.metaObject.addMetaData('classImplemenedVariables', attr, true);
            }
          } else {
            if (member === 'method') {
              this.metaObject.addMetaData('instanceImplemenedMethods', attr, true);
            } else {
              this.metaObject.addMetaData('instanceImplemenedVariables', attr, true);
            }
          }
        }
      });

      Reflect.defineProperty(CoreObject, 'initialize', {
        enumerable: true,
        configurable: true,
        value: function() {
          var attrType, classImplemenedMethods, classImplemenedVariables, instanceImplemenedMethods, instanceImplemenedVariables, k, ref2, ref3, ref4, ref5;
          this.constructor = RC.prototype.Class;
          assert(_.isFunction(this.Module.const), `Module of ${this.name} must be subclass of RC::Module`);
          if (this.Module.environment !== PRODUCTION) {
            ({classImplemenedVariables, classImplemenedMethods, instanceImplemenedVariables, instanceImplemenedMethods} = this);
            ref2 = this.classVirtualVariables;
            for (k in ref2) {
              if (!hasProp.call(ref2, k)) continue;
              ({attrType} = ref2[k]);
              assert(classImplemenedVariables[k] != null, `Absent implementation for virtual ${this.name}.${k}`);
            }
            ref3 = this.classVirtualMethods;
            for (k in ref3) {
              if (!hasProp.call(ref3, k)) continue;
              ({attrType} = ref3[k]);
              assert(classImplemenedMethods[k] != null, `Absent implementation for virtual ${this.name}.${k}()`);
            }
            ref4 = this.instanceVirtualVariables;
            for (k in ref4) {
              if (!hasProp.call(ref4, k)) continue;
              ({attrType} = ref4[k]);
              assert(instanceImplemenedVariables[k] != null, `Absent implementation for virtual ${this.name}::${k}`);
            }
            ref5 = this.instanceVirtualMethods;
            for (k in ref5) {
              if (!hasProp.call(ref5, k)) continue;
              ({attrType} = ref5[k]);
              if (k !== 'init') {
                assert(instanceImplemenedMethods[k] != null, `Absent implementation for virtual ${this.name}::${k}()`);
              }
            }
          }
          if (this.Module !== this || this.name === 'Module') {
            this.Module.const({
              [`${this.name}`]: this
            });
          }
          CACHE.set(this, this.name);
          return this;
        }
      });

      Reflect.defineProperty(CoreObject, 'initializeMixin', {
        enumerable: true,
        configurable: true,
        value: function() {
          this.constructor = RC.prototype.Class;
          return this;
        }
      });

      Reflect.defineProperty(CoreObject, cpmDefineProperty, {
        enumerable: true,
        value: function(config = {}) {
          var ParentType, Type, _default, async, attr, attrKind, attrType, checkTypesWrapper, configurable, constant, definition, get, getter, isAsync, isConstant, isFunction, isPrivate, isProtected, isPublic, isStatic, isUtility, isVirtual, level, memberKind, name, pointerOnRealPlace, sepor, set, setter, target, type;
          ({
            level,
            type,
            async,
            const: constant,
            attr,
            attrType,
            default: _default,
            get,
            set,
            configurable,
            isFunction,
            isUtility = false
          } = config);
          assert(this.isExtensible, `Class '${this.name}' has been frozen previously. Property '${attr}' can not be declared`);
          isVirtual = level === VIRTUAL;
          isPublic = level === PUBLIC;
          isPrivate = level === PRIVATE;
          isProtected = level === PROTECTED;
          isStatic = type === STATIC;
          isConstant = constant === CONST;
          isAsync = async === ASYNC;
          if (isVirtual) {
            if (isStatic) {
              if (isFunction) {
                this.metaObject.addMetaData('classVirtualMethods', attr, config);
              } else {
                this.metaObject.addMetaData('classVirtualVariables', attr, config);
              }
            } else {
              if (isFunction) {
                this.metaObject.addMetaData('instanceVirtualMethods', attr, config);
              } else {
                this.metaObject.addMetaData('instanceVirtualVariables', attr, config);
              }
            }
            return attr;
          }
          target = isStatic ? this : this.prototype;
          name = isPublic ? attr : isProtected ? Symbol.for(attr) : Symbol(attr);
          config.pointer = name;
          definition = {
            enumerable: true,
            configurable: configurable != null ? configurable : true
          };
          sepor = isStatic ? '.' : '::';
          Type = attrType;
          attrKind = isStatic ? 'static' : 'instance';
          memberKind = isFunction ? 'method' : 'variable';
          ParentType = isStatic ? isFunction ? this.classMethods[attr] : this.classVariables[attr] : isFunction ? this.instanceMethods[attr] : this.instanceVariables[attr];
          if (ParentType == null) {
            ParentType = isStatic ? isFunction ? this.classVirtualMethods[attr] : this.classVirtualVariables[attr] : isFunction ? this.instanceVirtualMethods[attr] : this.instanceVirtualVariables[attr];
          }
          ParentType = ParentType != null ? ParentType.attrType : void 0;
          if (isFunction) {
            if (this.Module.environment !== PRODUCTION) {
              if (attr !== 'init') {
                this.subtypeOf(attr, attrKind, memberKind, Type, ParentType);
              }
            }
            Reflect.defineProperty(_default, 'class', {
              value: this,
              enumerable: true
            });
            Reflect.defineProperty(_default, 'name', {
              value: attr,
              configurable: true
            });
            Reflect.defineProperty(_default, 'pointer', {
              value: name,
              configurable: true,
              enumerable: true
            });
            checkTypesWrapper = function(...args) {
              var className, co, data, ref2, self, tupleLength;
              className = isStatic ? this.name : this.constructor.name;
              if (this.Module.environment !== PRODUCTION) {
                this.Module.prototype.FunctionT(checkTypesWrapper.body);
                if (this.Module.prototype.FunctionT !== Type && this.Module.prototype.FunctorT.is(Type) && Type.meta.domain.length > 0) {
                  ({tupleLength} = checkTypesWrapper);
                  if (typeof checkTypesWrapper.argsTuple === "function") {
                    checkTypesWrapper.argsTuple(args.slice(0, tupleLength), [`${className}${sepor}${attr}${Type.meta.name}`]);
                  }
                }
              }
              self = this;
              if (isAsync) {
                co = (ref2 = this.Module.prototype.co) != null ? ref2 : RC.prototype.co;
                return co(function*() {
                  var data;
                  data = (yield* checkTypesWrapper.body.apply(self, args));
                  if (self.Module.environment !== PRODUCTION) {
                    if (self.Module.prototype.FunctionT !== Type && self.Module.prototype.FunctorT.is(Type)) {
                      self.Module.prototype.createByType(Type.meta.codomain, data, [`${className}${sepor}${attr}${Type.meta.name}`]);
                    }
                  }
                  return data;
                });
              } else {
                data = checkTypesWrapper.body.apply(this, args);
                if (this.Module.environment !== PRODUCTION) {
                  if (this.Module.prototype.FunctionT !== Type && this.Module.prototype.FunctorT.is(Type)) {
                    this.Module.prototype.createByType(Type.meta.codomain, data, [`${className}${sepor}${attr}${Type.meta.name}`]);
                  }
                }
                return data;
              }
            };
            Reflect.defineProperty(checkTypesWrapper, 'tupleLength', {
              configurable: false,
              enumerable: true,
              writable: false,
              value: (function() {
                var ArgsTypes, ref2, ref3, ref4, ref5, ref6, ref7;
                ArgsTypes = Type.meta.domain;
                if (((ref2 = this.Module) != null ? (ref3 = ref2.prototype) != null ? ref3.getOptionalArgumentsIndex : void 0 : void 0) && ((ref4 = this.Module) != null ? (ref5 = ref4.prototype) != null ? ref5.FunctionT : void 0 : void 0) && ((ref6 = this.Module) != null ? (ref7 = ref6.prototype) != null ? ref7.FunctorT : void 0 : void 0) && this.Module.prototype.FunctionT !== Type && this.Module.prototype.FunctorT.is(Type)) {
                  return this.Module.prototype.getOptionalArgumentsIndex(ArgsTypes);
                }
              })()
            });
            Reflect.defineProperty(checkTypesWrapper, 'argsTuple', {
              configurable: false,
              enumerable: true,
              writable: false,
              value: (function() {
                var ArgsTypes, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tupleLength;
                if (((ref2 = this.Module) != null ? (ref3 = ref2.prototype) != null ? ref3.getOptionalArgumentsIndex : void 0 : void 0) && ((ref4 = this.Module) != null ? (ref5 = ref4.prototype) != null ? ref5.TupleG : void 0 : void 0) && ((ref6 = this.Module) != null ? (ref7 = ref6.prototype) != null ? ref7.FunctionT : void 0 : void 0) && ((ref8 = this.Module) != null ? (ref9 = ref8.prototype) != null ? ref9.FunctorT : void 0 : void 0)) {
                  if (this.Module.prototype.FunctionT !== Type && this.Module.prototype.FunctorT.is(Type)) {
                    ArgsTypes = Type.meta.domain;
                    ({tupleLength} = checkTypesWrapper);
                    if (domainLength !== 0) {
                      return this.Module.prototype.TupleG(ArgsTypes.slice(0, tupleLength));
                    }
                  }
                }
              })()
            });
            Reflect.defineProperty(_default, 'wrapper', {
              value: checkTypesWrapper,
              enumerable: true
            });
            Reflect.defineProperty(checkTypesWrapper, 'class', {
              value: this,
              enumerable: true
            });
            Reflect.defineProperty(checkTypesWrapper, 'name', {
              value: attr,
              configurable: true
            });
            Reflect.defineProperty(checkTypesWrapper, 'pointer', {
              value: name,
              configurable: true,
              enumerable: true
            });
            Reflect.defineProperty(checkTypesWrapper, 'body', {
              value: _default,
              enumerable: true
            });
            definition.value = checkTypesWrapper;
            config.wrapper = checkTypesWrapper;
          } else if (isConstant) {
            definition.writable = false;
            definition.value = _default;
          } else {
            if (this.Module.environment !== PRODUCTION) {
              this.subtypeOf(attr, attrKind, memberKind, Type, ParentType);
            }
            pointerOnRealPlace = Symbol(`_${attr}`);
            // TODO: сделать оптимизацию: если getter и setter не указаны,
            // то не использовать getter и setter, а объявлять через value
            definition.get = getter = function() {
              var className, value;
              value = this[pointerOnRealPlace];
              if ((get != null) && _.isFunction(get)) {
                value = get.apply(this, [value]);
              }
              if (this.Module.environment !== PRODUCTION) {
                if (!getter.isChecked) {
                  className = isStatic ? this.name : this.constructor.name;
                  if (typeof Type === "function") {
                    Type(value, [`${className}${sepor}${attr}`]);
                  }
                  getter.isChecked = true;
                }
              }
              return value;
            };
            definition.set = setter = function(newValue) {
              var className;
              if ((set != null) && _.isFunction(set)) {
                newValue = set.apply(this, [newValue]);
              }
              if (this.Module.environment !== PRODUCTION) {
                // unless setter.typeCache.has newValue
                className = isStatic ? this.name : this.constructor.name;
                if (typeof Type === "function") {
                  Type(newValue, [`${className}${sepor}${attr}`]);
                }
                // setter.typeCache.add newValue
                getter.isChecked = true;
              }
              this[pointerOnRealPlace] = newValue;
              return newValue;
            };
            getter.isChecked = false;
            // setter.typeCache = new Set()
            if (_default != null) {
              if (this.Module.environment !== PRODUCTION) {
                if (typeof Type === "function") {
                  Type(_default, [`${this.name}${sepor}${attr}`]);
                }
                // setter.typeCache.add _default
                getter.isChecked = true;
              }
              target[pointerOnRealPlace] = _default;
            }
          }
          Reflect.defineProperty(target, name, definition);
          if (isConstant) {
            this.metaObject.addMetaData('constants', attr, config);
          } else if (isStatic) {
            if (isFunction) {
              this.metaObject.addMetaData('classMethods', attr, config);
            } else {
              this.metaObject.addMetaData('classVariables', attr, config);
            }
          } else {
            if (isUtility) {
              this.metaObject.addMetaData('utilities', attr, config);
            } else if (isFunction) {
              this.metaObject.addMetaData('instanceMethods', attr, config);
            } else {
              this.metaObject.addMetaData('instanceVariables', attr, config);
            }
          }
          return name;
        }
      });

      // метод, чтобы объявить асинхронный метод класса или инстанса
      // этот метод возвращает промис, а оберточная функция, которая будет делать проверку типов входящих и возвращаемых значений тоже будет ретурнить промис, а внутри будет использовать yield для ожидания резолва обворачиваемой функции
      Reflect.defineProperty(CoreObject, 'async', {
        enumerable: true,
        value: function(...args) {
          var attr, attrType, codomain, config, definition, domain, isFunction, ref2, typeDefinition;
          assert(args.length > 0, 'arguments is required');
          [typeDefinition] = args;
          assert(_.isPlainObject(typeDefinition), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to async(typeDefinition) (expected a plain object or @static definition)`);
          config = args.length === 1 && (typeDefinition.attr != null) && (typeDefinition.attrType != null) ? typeDefinition : (attr = Object.keys(typeDefinition)[0], attrType = typeDefinition[attr], definition = (ref2 = args[1]) != null ? ref2 : {}, attrType === Function ? attrType = this.Module.prototype.FuncG(definition.args, definition.return) : attrType = this.Module.prototype.AccordG(attrType), isFunction = (attrType === this.Module.prototype.FunctionT || attrType === this.Module.prototype.AsyncFunctionT || attrType === this.Module.prototype.GeneratorFunctionT) || this.Module.prototype.FunctorT.is(attrType), definition.attr = attr, definition.attrType = attrType, definition.isFunction = isFunction, definition);
          if (config.attrType.meta.kind === 'func') {
            ({domain, codomain} = config.attrType.meta);
            config.attrType = this.Module.prototype.AsyncFuncG(domain, codomain);
          }
          config.async = ASYNC;
          return config;
        }
      });

      // метод чтобы объявить атрибут или метод класса
      Reflect.defineProperty(CoreObject, 'static', {
        enumerable: true,
        value: function(...args) {
          var attr, attrType, config, definition, isFunction, ref2, typeDefinition;
          assert(args.length > 0, 'arguments is required');
          [typeDefinition] = args;
          assert(_.isPlainObject(typeDefinition), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to static(typeDefinition) (expected a plain object or @async definition)`);
          config = args.length === 1 && (typeDefinition.attr != null) && (typeDefinition.attrType != null) ? typeDefinition : (attr = Object.keys(typeDefinition)[0], attrType = typeDefinition[attr], definition = (ref2 = args[1]) != null ? ref2 : {}, attrType === Function ? attrType = this.Module.prototype.FuncG(definition.args, definition.return) : attrType = this.Module.prototype.AccordG(attrType), isFunction = (attrType === this.Module.prototype.FunctionT || attrType === this.Module.prototype.AsyncFunctionT || attrType === this.Module.prototype.GeneratorFunctionT) || this.Module.prototype.FunctorT.is(attrType), definition.attr = attr, definition.attrType = attrType, definition.isFunction = isFunction, definition);
          config.type = STATIC;
          return config;
        }
      });

      Reflect.defineProperty(CoreObject, 'public', {
        enumerable: true,
        value: function(...args) {
          var attr, attrType, config, definition, hasBody, isFunction, ref2, ref3, typeDefinition;
          assert(args.length > 0, 'arguments is required');
          [typeDefinition] = args;
          assert(_.isPlainObject(typeDefinition), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to public(typeDefinition) (expected a plain object or @static or/and @async definition)`);
          config = args.length === 1 && (typeDefinition.attr != null) && (typeDefinition.attrType != null) ? (hasBody = _.isPlainObject(typeDefinition) && ((typeDefinition != null ? typeDefinition.default : void 0) != null), assert(!(typeDefinition.isFunction && !hasBody), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to public(typeDefinition) (expected a plain object with {default: () => {}})`), typeDefinition) : (attr = Object.keys(typeDefinition)[0], attrType = typeDefinition[attr], definition = (ref2 = args[1]) != null ? ref2 : {}, attrType === Function ? attrType = this.Module.prototype.FuncG(definition.args, definition.return) : attrType = this.Module.prototype.AccordG(attrType), isFunction = (attrType === this.Module.prototype.FunctionT || attrType === this.Module.prototype.AsyncFunctionT || attrType === this.Module.prototype.GeneratorFunctionT) || this.Module.prototype.FunctorT.is(attrType), hasBody = _.isPlainObject(args[1]) && (((ref3 = args[1]) != null ? ref3.default : void 0) != null), assert(!(isFunction && !hasBody), `Invalid argument config ${assert.stringify(args[1])} supplied to public(typeDefinition, config) (expected a plain object with {default: () => {}})`), definition.attr = attr, definition.attrType = attrType, definition.isFunction = isFunction, definition);
          config.level = PUBLIC;
          return this[cpmDefineProperty](config);
        }
      });

      // NOTE: like public but outter objects does not get data or call methods
      Reflect.defineProperty(CoreObject, 'protected', {
        enumerable: true,
        value: function(...args) {
          var attr, attrType, config, definition, hasBody, isFunction, ref2, ref3, typeDefinition;
          assert(args.length > 0, 'arguments is required');
          [typeDefinition] = args;
          assert(_.isPlainObject(typeDefinition), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to protected(typeDefinition) (expected a plain object or @static or/and @async definition)`);
          config = args.length === 1 && (typeDefinition.attr != null) && (typeDefinition.attrType != null) ? (hasBody = _.isPlainObject(typeDefinition) && ((typeDefinition != null ? typeDefinition.default : void 0) != null), assert(!(typeDefinition.isFunction && !hasBody), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to protected(typeDefinition) (expected a plain object with {default: () => {}})`), typeDefinition) : (attr = Object.keys(typeDefinition)[0], attrType = typeDefinition[attr], definition = (ref2 = args[1]) != null ? ref2 : {}, attrType === Function ? attrType = this.Module.prototype.FuncG(definition.args, definition.return) : attrType = this.Module.prototype.AccordG(attrType), isFunction = (attrType === this.Module.prototype.FunctionT || attrType === this.Module.prototype.AsyncFunctionT || attrType === this.Module.prototype.GeneratorFunctionT) || this.Module.prototype.FunctorT.is(attrType), hasBody = _.isPlainObject(args[1]) && (((ref3 = args[1]) != null ? ref3.default : void 0) != null), assert(!(isFunction && !hasBody), `Invalid argument config ${assert.stringify(args[1])} supplied to protected(typeDefinition, config) (expected a plain object with {default: () => {}})`), definition.attr = attr, definition.attrType = attrType, definition.isFunction = isFunction, definition);
          if (!/^[~]/.test(config.attr)) {
            config.attr = '~' + config.attr;
          }
          config.level = PROTECTED;
          return this[cpmDefineProperty](config);
        }
      });

      // NOTE: like public but outter objects does not get data or call methods
      Reflect.defineProperty(CoreObject, 'private', {
        enumerable: true,
        value: function(...args) {
          var attr, attrType, config, definition, hasBody, isFunction, ref2, ref3, typeDefinition;
          assert(args.length > 0, 'arguments is required');
          [typeDefinition] = args;
          assert(_.isPlainObject(typeDefinition), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to private(typeDefinition) (expected a plain object or @static or/and @async definition)`);
          config = args.length === 1 && (typeDefinition.attr != null) && (typeDefinition.attrType != null) ? (hasBody = _.isPlainObject(typeDefinition) && ((typeDefinition != null ? typeDefinition.default : void 0) != null), assert(!(typeDefinition.isFunction && !hasBody), `Invalid argument typeDefinition ${assert.stringify(typeDefinition)} supplied to private(typeDefinition) (expected a plain object with {default: () => {}})`), typeDefinition) : (attr = Object.keys(typeDefinition)[0], attrType = typeDefinition[attr], definition = (ref2 = args[1]) != null ? ref2 : {}, attrType === Function ? attrType = this.Module.prototype.FuncG(definition.args, definition.return) : attrType = this.Module.prototype.AccordG(attrType), isFunction = (attrType === this.Module.prototype.FunctionT || attrType === this.Module.prototype.AsyncFunctionT || attrType === this.Module.prototype.GeneratorFunctionT) || this.Module.prototype.FunctorT.is(attrType), hasBody = _.isPlainObject(args[1]) && (((ref3 = args[1]) != null ? ref3.default : void 0) != null), assert(!(isFunction && !hasBody), `Invalid argument config ${assert.stringify(args[1])} supplied to private(typeDefinition, config) (expected a plain object with {default: () => {}})`), definition.attr = attr, definition.attrType = attrType, definition.isFunction = isFunction, definition);
          if (!/^[_]/.test(config.attr)) {
            config.attr = '_' + config.attr;
          }
          config.level = PRIVATE;
          return this[cpmDefineProperty](config);
        }
      });

      Reflect.defineProperty(CoreObject, 'const', {
        enumerable: true,
        value: function(definition) {
          var attr;
          assert(_.isPlainObject(definition), `Invalid argument definition ${assert.stringify(definition)} supplied to const(definition) (expected a plain object)`);
          attr = Object.keys(definition)[0];
          return this[cpmDefineProperty]({
            attr,
            attrType: null,
            const: CONST,
            level: PUBLIC,
            configurable: false,
            default: definition[attr]
          });
        }
      });

      // @Module: RC

      // General class API
      Reflect.defineProperty(CoreObject, 'module', {
        enumerable: true,
        value: function(module) {
          return this.Module = module;
        }
      });

      Reflect.defineProperty(CoreObject.prototype, 'Module', {
        enumerable: true,
        get: function() {
          return this.constructor.Module;
        }
      });

      Reflect.defineProperty(CoreObject, 'moduleName', {
        enumerable: true,
        value: function() {
          return this.Module.name;
        }
      });

      Reflect.defineProperty(CoreObject.prototype, 'moduleName', {
        enumerable: true,
        value: function() {
          return this.Module.name;
        }
      });

      Reflect.defineProperty(CoreObject.prototype, 'CLASS_KEYS', {
        writable: false,
        configurable: false,
        enumerable: true,
        value: CLASS_KEYS
      });

      Reflect.defineProperty(CoreObject.prototype, 'INSTANCE_KEYS', {
        writable: false,
        configurable: false,
        enumerable: true,
        value: INSTANCE_KEYS
      });

      CoreObject.metaObject.addMetaData('constants', 'CLASS_KEYS', {
        attr: 'CLASS_KEYS',
        attrType: Array,
        const: CONST,
        configurable: false,
        default: CLASS_KEYS
      });

      CoreObject.metaObject.addMetaData('constants', 'INSTANCE_KEYS', {
        attr: 'INSTANCE_KEYS',
        attrType: Array,
        const: CONST,
        configurable: false,
        default: INSTANCE_KEYS
      });

      Reflect.defineProperty(CoreObject, 'superclass', {
        enumerable: true,
        value: function() {
          return Reflect.getPrototypeOf(this);
        }
      });

      Reflect.defineProperty(CoreObject, 'class', {
        enumerable: true,
        value: function() {
          return this.constructor;
        }
      });

      Reflect.defineProperty(CoreObject.prototype, 'class', {
        enumerable: true,
        value: function() {
          return this.constructor;
        }
      });

      Reflect.defineProperty(CoreObject, 'mixins', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('mixins', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'interfaces', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('interfaces', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'classMethods', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('classMethods', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'instanceMethods', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('instanceMethods', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'classVirtualMethods', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('classVirtualMethods', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'instanceVirtualMethods', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('instanceVirtualMethods', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'classImplemenedMethods', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('classImplemenedMethods', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'instanceImplemenedMethods', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('instanceImplemenedMethods', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'constants', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('constants', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'instanceVariables', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('instanceVariables', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'classVariables', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('classVariables', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'instanceVirtualVariables', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('instanceVirtualVariables', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'classVirtualVariables', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('classVirtualVariables', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'instanceImplemenedVariables', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('instanceImplemenedVariables', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'classImplemenedVariables', {
        enumerable: true,
        get: function() {
          return this.metaObject.getGroup('classImplemenedVariables', false);
        }
      });

      Reflect.defineProperty(CoreObject, 'restoreObject', {
        enumerable: true,
        value: function(Module, replica) {
          var co, ref2, self;
          assert(replica != null, "Replica cann`t be empty");
          assert(replica.class != null, "Replica type is required");
          assert((replica != null ? replica.type : void 0) === 'instance', `Replica type isn\`t \`instance\`. It is \`${replica.type}\``);
          co = (ref2 = this.Module.prototype.co) != null ? ref2 : RC.prototype.co;
          self = this;
          return co(function*() {
            var instance, vcClass;
            // vcClass.classMethods['restoreObject'].async is ASYNC
            instance = replica.class === self.name ? self.new() : (vcClass = Module.prototype[replica.class], (yield vcClass.restoreObject(Module, replica)));
            // else
            //   vcClass.restoreObject Module, replica
            return instance;
          });
        }
      });

      Reflect.defineProperty(CoreObject, 'replicateObject', {
        enumerable: true,
        value: function(aoInstance) {
          var ref2, replica;
          assert(aoInstance != null, "Argument cann`t be empty");
          replica = {
            type: 'instance',
            class: aoInstance.constructor.name
          };
          return ((ref2 = this.Module.prototype.Promise) != null ? ref2 : RC.prototype.Promise).resolve(replica);
        }
      });

      // дополнительно можно объявить:
      // privateClassMethods, protectedClassMethods, publicClassMethods
      // privateInstanceMethods, protectedInstanceMethods, publicInstanceMethods
      // privateClassVariables, protectedClassVariables, publicClassVariables
      // privateInstanceVariables, protectedInstanceVariables, publicInstanceVariables
      Reflect.defineProperty(CoreObject.prototype, 'init', {
        enumerable: true,
        value: function(...args) {
          return this;
        }
      });

      Reflect.defineProperty(CoreObject, 'displayName', {
        configurable: false,
        enumerable: true,
        get: function() {
          return this.name;
        }
      });

      Reflect.defineProperty(CoreObject, 'cacheStrategy', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: WEAK
      });

      Reflect.defineProperty(CoreObject, 'ID', {
        configurable: false,
        enumerable: true,
        get: function() {
          return this.name;
        }
      });

      Reflect.defineProperty(CoreObject, 'meta', {
        configurable: false,
        enumerable: true,
        get: function() {
          return {
            kind: 'class',
            name: this.name,
            identity: true
          };
        }
      });

      CoreObject.module(RC);

      return CoreObject;

    }).call(this);
    require('./Class')(RC);
    RC.prototype.CoreObject.constructor = RC.prototype.Class;
    RC.prototype.MetaObject.constructor = RC.prototype.Class;
    CACHE.set(RC.prototype.CoreObject, 'CoreObject');
    return RC.prototype.CoreObject;
  };

}).call(this);
